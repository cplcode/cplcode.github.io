! Fast-Fourier transform library (actually INCLUDed from fft.cmn)   !
! and utilities to read the REAL values encoded in a COMPLEX array. !
! For usage see fft.info.                                           !
!                                                                   !
! Copyright 1997-2021 Paolo Luchini http://CPLcode.net              !
! Released under the attached LICENSE.                              !
!                                                                   !
! Code maturity: green.                                             !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

USE complex
type=COMPLEX

SUBROUTINE FFTSETUP(INTEGER N) FOLLOWS
INLINE SUBROUTINE IFT(type R^(*)) = IFT(R,R)
SUBROUTINE IFT(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE FFT(type R^(*)) = FFT(R,R)
SUBROUTINE FFT(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE RFT(type R^(*)) = RFT(R,R)
SUBROUTINE RFT(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE HFT(type R^(*)) = HFT(R,R)
SUBROUTINE HFT(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE IFTU(type R^(*)) = IFTU(R,R)
SUBROUTINE IFTU(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE FFTU(type R^(*)) = FFTU(R,R)
SUBROUTINE FFTU(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE RFTU(type R^(*)) = RFTU(R,R)
SUBROUTINE RFTU(type Rin^(*), Rout^(*)) FOLLOWS
INLINE SUBROUTINE HFTU(type R^(*)) = HFTU(R,R)
SUBROUTINE HFTU(type Rin^(*), Rout^(*)) FOLLOWS

BOOLEAN FUNCTION FFTfit(INTEGER VARIABLE N)
  IF N<8 THEN RESULT=FALSE ELSE
    LOOP UNTIL ODD(N); N = ~ RSHIFTED 1; REPEAT LOOP
    RESULT = (N=1 OR N=3)
  END IF
END FFTfit

MODULE fft

SUBROUTINE ReverseInc(INTEGER K^, N)
  INTEGER M=N>>1
  LOOP ri
    IF M>K THEN K=~+M; EXIT ri
    K=~-M
    IF M BITAND 1 # 0 THEN K=~+1; EXIT ri
    M =~>> 1
  REPEAT ri
END ReverseInc

STRUCTURE[
  INTEGER LASTN=1
  POINTER TO ARRAY(*) OF COMPLEX CEXP
  POINTER TO ARRAY(*) OF INTEGER RI
] BUF

SUBROUTINE FFTSETUP(INTEGER N)
  WITH BUF
  IF LASTN>1 THEN FREE CEXP,RI
  IF N>1 THEN
    IF N MOD 3 =0 THEN LASTN=N ELSE LASTN=3*N
    RI=NEW ARRAY(0..LASTN+LASTN DIV 3-1) OF INTEGER
    INTEGER K=0; DO RI(J)=K; ReverseInc(K,LASTN) FOR J=0 TO LASTN-1
    INTEGER K=0; DO RI(LASTN+J)=K; ReverseInc(K,LASTN DIV 3) FOR J=0 TO LASTN DIV 3 -1
    EXCEPT LASTN<=0 ! To quench gcc-8 alloc-size-larger-than warning
    CEXP=NEW ARRAY(0..3*LASTN DIV 4 - 1) OF COMPLEX
    DO CEXP(K)=EXP(I*K*2*PI/LASTN) FOR ALL K
  ELSE LASTN=N
END FFTSETUP

C3=SIN(PI/3)

INLINE SUBROUTINE BT4(POINTER TO ARRAY(*) OF type R; type R0,R1,R2,R3)
!          R(J)=R(J)+R(J+M)+R(J+2*M)+R(J+3*M)
!          R(J+2*M)=R(J)-R(J+M)+R(J+2*M)-R(J+3*M)
!          R(J+M)=R(J)+I*R(J+M)-R(J+2*M)-I*R(J+3*M)
!          R(J+3*M)=R(J)-I*R(J+M)-R(J+2*M)+I*R(J+3*M)
!(
  A=R0+R1; B=R0-R1
  C=I*(R2-R3); D=R2+R3
  R(-1)=A+D
  R(0)=B+C
  R(1)=A-D
  R(2)=B-C
!)
  A0P2R=R0.REAL+R1.REAL
  A0M2R=R0.REAL-R1.REAL
  A1M3R=R2.REAL-R3.REAL
  A1P3R=R2.REAL+R3.REAL
  A1M3I=R2.IMAG-R3.IMAG
  R(-1).REAL=A0P2R+A1P3R
  R(1).REAL=A0P2R-A1P3R
  R(2).REAL=A0M2R+A1M3I
  R(0).REAL=A0M2R-A1M3I
  A0P2I=R0.IMAG+R1.IMAG
  A0M2I=R0.IMAG-R1.IMAG
  A1P3I=R2.IMAG+R3.IMAG
  R(-1).IMAG=A0P2I+A1P3I
  R(1).IMAG=A0P2I-A1P3I
  R(2).IMAG=A0M2I-A1M3R
  R(0).IMAG=A0M2I+A1M3R
END BT4

SUBROUTINE BTFLY(POINTER TO ARRAY(*) OF type tv; INTEGER N; INTEGER VARIABLE M)
  WITH BUF
  INTEGER K1=LASTN DIV M
  DO
    IF N MOD (M<<2) = 0 THEN
      M1=N DIV(M<<2)
      K1=K1>>2
      POINTER INTO tv(M*(*)) Rj=1
      DO
        BT4{Rj(*),Rj(-1),Rj(0),Rj(1),Rj(2)}
	INC Rj,4
      FOR M1 TIMES
      INTEGER K=0
      LOOP FOR H=1 TO M-1
        K=K+K1
        C1=^CEXP(2*K+K*(*))
        POINTER INTO tv(H+M*(*)) RR=1
        DO
	  RR(0)=~*C1(0)
	  RR(1)=~*C1(-1)
	  RR(2)=~*C1(1)
          BT4(RR(*),RR(-1),RR(0),RR(1),RR(2))
          INC RR,4
        FOR M1 TIMES
      REPEAT LOOP
      M=M<<2
    ELSE IF N MOD (M<<1) = 0 THEN
      M1=N DIV (M<<1)
      K1=K1>>1
      INTEGER K=0
      LOOP FOR H=0 TO M-1
        POINTER INTO tv(H+M*(*)) RR=1
        DO
	  A=CEXP(K)*RR(0)
	  RR(0)=RR(-1)-A
	  RR(-1)=~+A
	  !(
          AR=CEXP(K).REAL*RR(0).REAL-CEXP(K).IMAG*RR(0).IMAG
          AI=CEXP(K).REAL*RR(0).IMAG+CEXP(K).IMAG*RR(0).REAL
          RR(0).REAL=RR(-1).REAL-AR
          RR(0).IMAG=RR(-1).IMAG-AI
          RR(-1).REAL=~+AR
          RR(-1).IMAG=~+AI
	  !)
	  INC RR,2
        FOR M1 TIMES
        K=K+K1
      REPEAT LOOP
      M=M<<1
!    ELSE IF N MOD (3*M) = 0 THEN
    ELSE IF N=3*M THEN
!      M3=3*M
      K1=K1 DIV 3
      INTEGER K=0
      LOOP FOR H=0 TO M-1
        C1=^CEXP(K+K*(*))
        POINTER INTO tv(H+M*(*)) RR=1
!      DO
          AR=C1(0).REAL*RR(0).REAL-C1(0).IMAG*RR(0).IMAG
          AI=C1(0).REAL*RR(0).IMAG+C1(0).IMAG*RR(0).REAL
          BR=C1(1).REAL*RR(1).REAL-C1(1).IMAG*RR(1).IMAG
          BI=C1(1).REAL*RR(1).IMAG+C1(1).IMAG*RR(1).REAL
          CR=RR(-1).REAL-(AR+BR)*0.5
          RR(-1).REAL=~+AR+BR
          DR=(AR-BR)*C3
          CI=RR(-1).IMAG-(AI+BI)*0.5
          RR(-1).IMAG=~+AI+BI
          DI=(AI-BI)*C3
          RR(0).REAL=CR-DI
          RR(1).REAL=CR+DI
          RR(1).IMAG=CI-DR
          RR(0).IMAG=CI+DR
!          INC RR,3
!        FOR M1 TIMES
        K=K+K1
      REPEAT LOOP
!      M=M3
       M=N
    ELSE ERROR "This FFT cannot handle " N " points"
  UNTIL M>=N
END BTFLY

INLINE SUBROUTINE BT4I(POINTER TO ARRAY(*) OF type Rin,Rout) 
!(
  A=R(-1)+R(1); B=R(-1)-R(1)
  C=I*(R(0)-R(2)); D=R(0)+R(2)
  R(-1)=A+D
  R(0)=A-D
  R(1)=B-C
  R(2)=B+C
!)  
  A0P2R=Rin(-1).REAL+Rin(1).REAL
  A0M2R=Rin(-1).REAL-Rin(1).REAL
  A1M3R=Rin(0).REAL-Rin(2).REAL
  A1P3R=Rin(0).REAL+Rin(2).REAL
  A1M3I=Rin(0).IMAG-Rin(2).IMAG
  Rout(-1).REAL=A0P2R+A1P3R
  Rout(0).REAL=A0P2R-A1P3R
  Rout(1).REAL=A0M2R+A1M3I
  Rout(2).REAL=A0M2R-A1M3I
  A0P2I=Rin(-1).IMAG+Rin(1).IMAG
  A0M2I=Rin(-1).IMAG-Rin(1).IMAG
  A1P3I=Rin(0).IMAG+Rin(2).IMAG
  Rout(-1).IMAG=A0P2I+A1P3I
  Rout(0).IMAG=A0P2I-A1P3I
  Rout(1).IMAG=A0M2I-A1M3R
  Rout(2).IMAG=A0M2I+A1M3R
END BT4I

SUBROUTINE BTFLYI(POINTER TO ARRAY(*) OF type tv; INTEGER N)
  WITH BUF
  INTEGER M=N
  INTEGER K1=LASTN DIV M
  IF M MOD 3 = 0 THEN
    M=M DIV 3
    INTEGER K=0
    LOOP FOR H=0 TO M-1
      POINTER INTO tv(H+M*(*)) RR=1
      C=RR(0)+RR(1)
      AMB=I*C3*(RR(1)-RR(0))
      APB=RR(-1)-C*0.5
      RR(-1)=~+C
      C1=^CEXP(K+K*(*))
      RR(0)=(APB+AMB)*CONJG(C1(0))
      RR(1)=(APB-AMB)*CONJG(C1(1))
      K=K+K1
    REPEAT LOOP
    K1=K1*3
  END IF
  INTEGER MN=M; DO MN=MN >> 2 UNTIL MN<4; IF MN = 2 THEN
    M1=N DIV M
    M=M>>1
    INTEGER K=0
    LOOP FOR H=0 TO M-1
      POINTER INTO tv(H+M*(*)) RR=1
      DO
        A=RR(-1)-RR(0)
	RR(-1)=RR(-1)+RR(0)
	RR(0)=A*CONJG(CEXP(K))
	INC RR,2
      FOR M1 TIMES
      K=K+K1
    REPEAT LOOP
    K1=K1<<1
  END IF
  LOOP WHILE M BITAND 15 =0
    M1=N DIV M
    M=M>>2
    POINTER INTO tv(M*(*)) Rj=1
    DO
      BT4I(Rj(*),Rj(*))
      INC Rj,4
    FOR M1 TIMES
    INTEGER K=0
    LOOP FOR H=1 TO M-1
      K=K+K1
      C1=^CEXP(2*K+K*(*))
      POINTER INTO tv(H+M*(*)) RR=1
      DO
        BT4I(RR(*),RR(*))
	RR(0)=~*CONJG(C1(0))
	RR(1)=~*CONJG(C1(-1))
	RR(2)=~*CONJG(C1(1))
        INC RR,4
      FOR M1 TIMES
    REPEAT LOOP
    K1=K1<<2
  REPEAT
  IF M#4 THEN ERROR "This FFT cannot handle " N " points"
END BTFLYI

!(
SUBROUTINE BTFLY2(type R^(*))
  N=R.LENGTH
  INTEGER M=1
  COMPLEX C1=-1
  DO
    COMPLEX C=1
    M2=2*M
    LOOP FOR H=0 TO M-1
      C=C*C1
      DO
        A=C*R(J+M)
        R(J+M)=R(J)-A
        R(J)=R(J)+A
      FOR J=H TO N-1 BY M2
    REPEAT LOOP
    M=M2
    C1=SQRT(C1)
  UNTIL M=N
END BTFLY2

SUBROUTINE BTFLY2I(type R^(*))
  N=R.LENGTH
  INTEGER M2=2
  COMPLEX C1=-1
  DO
    M2=2*M2
    C1=SQRT(C1)
  UNTIL M2=N
  DO
    COMPLEX C=1
    INTEGER M=M2 DIV 2
    INTEGER H
    LOOP FOR H=0 TO M-1
      C=C*CONJG(C1)
      INTEGER J
      DO
	A=R(J)-R(J+M)
	R(J)=R(J)+R(J+M)
	R(J+M)=A*C
      FOR J=H TO N-1 BY M2
    REPEAT LOOP
    M2=M
    C1=C1*C1
  UNTIL M2=1
END BTFLY2I
!)

SUBROUTINE IFT(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH
  IF LASTN MOD N # 0 THEN FFTSETUP(N)
  INTEGER K1=LASTN DIV N
  POINTER INTO RI((*)) K
  IF K1 MOD 3 #0 THEN K=0 ELSE K=LASTN; K1=K1 DIV 3  
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  POINTER INTO tempVEC(0..Rin.HI) R=1
  DO
    R0=^Rin(K(0)); INC K,K1; R1=^Rin(K(0)); INC K,K1; R2=^Rin(K(0)); INC K,K1; R3=^Rin(K(0)); INC K,K1
    BT4(R(*),R0,R1,R2,R3)
    R=R+4
  FOR N>>2 TIMES
  !(
  DO
      R(0)=Rin[K(0)]
      INC K
    FOR R INTO tempVEC(0..Rin.HI)
    !)    
BTFLY(tempVEC,N,4)
  Rout(*)=tempVEC
END IFT

SUBROUTINE FFT(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH
  IF LASTN MOD N # 0 THEN FFTSETUP(N)
  Ninv=1/N
  INTEGER K1=LASTN DIV N
  POINTER INTO RI((*)) K
  IF K1 MOD 3 #0 THEN K=0 ELSE K=LASTN; K1=K1 DIV 3
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  POINTER INTO tempVEC(0..Rin.HI) R=1
  MODULE
    INC K,K1; R11=^Rin(N-K(0)); INC K,K1; R22=^Rin(N-K(0)); INC K,K1; R33=^Rin(N-K(0)); INC K,K1
    BT4(R(*),Rin(0)*Ninv,R11*Ninv,R22*Ninv,R33*Ninv)
  END MODULE
  DO
    R00=^Rin(N-K(0)); INC K,K1; R11=^Rin(N-K(0)); INC K,K1; R22=^Rin(N-K(0)); INC K,K1; R33=^Rin(N-K(0)); INC K,K1
    R=R+4
    BT4(R(*),R00*Ninv,R11*Ninv,R22*Ninv,R33*Ninv)
  FOR N>>2 -1 TIMES
  BTFLY(tempVEC,N,4)
  Rout(*)=tempVEC
END FFT

SUBROUTINE RFT(type Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH BITAND -2
  IF LASTN MOD (2*N) # 0 THEN FFTSETUP(2*N)
  Rout(0).REAL=Rin(0).REAL
  Rout(0).IMAG=Rin(0).REAL
  IF Rin.LENGTH BITAND 1 # 0 THEN
    Rout(0).REAL=~+Rin(N).REAL
    Rout(0).IMAG=~-Rin(N).REAL
  END IF
  POINTER INTO CEXP(LASTN DIV (N<<1)*(*)) C=0
  DO
    TYPEOF(Rin(0).REAL) AR,AI
    AR=Rin(J).REAL-Rin(N-J).REAL
    AI=Rin(J).IMAG+Rin(N-J).IMAG
    C=C+1
    BR=-C(0).IMAG*AR-C(0).REAL*AI
    BI=C(0).REAL*AR-C(0).IMAG*AI
!(    
    tempVEC(J).REAL=(Rin(J).REAL+Rin(N-J).REAL+BR)*0.5
    tempVEC(J).IMAG=(Rin(J).IMAG-Rin(N-J).IMAG+BI)*0.5
    tempVEC(N-J).REAL=tempVEC(J).REAL-BR
    tempVEC(N-J).IMAG=BI-tempVEC(J).IMAG
!)    
    Rout(J).REAL=Rin(J).REAL+Rin(N-J).REAL+BR
    Rout(J).IMAG=Rin(J).IMAG-Rin(N-J).IMAG+BI
    Rout(N-J).REAL=Rout(J).REAL-BR-BR
    Rout(N-J).IMAG=BI+BI-Rout(J).IMAG
  FOR J=1 TO N>>1
  IFT(Rout(0..N-1),Rout(0..N-1))
END RFT

SUBROUTINE HFT(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH BITAND -2
  IF LASTN MOD (2*N) # 0 THEN FFTSETUP(2*N)
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  FFT(Rin(0..N-1),tempVEC(0..N-1))
  Rout(0)=(tempVEC(0).REAL+tempVEC(0).IMAG)*0.5
  IF Rout.LENGTH BITAND 1 # 0 THEN
    Rout(N)=Rout(0).REAL-tempVEC(0).IMAG
  END IF
  POINTER INTO CEXP(LASTN DIV (N<<1)*(*)) C=0
  DO
    AR=tempVEC(J).REAL-tempVEC(N-J).REAL
    AI=tempVEC(J).IMAG+tempVEC(N-J).IMAG
    C=C+1
    BR=-C(0).IMAG*AR+C(0).REAL*AI
    BI=-C(0).REAL*AR-C(0).IMAG*AI
!(    
    Rout(J).REAL=(Rout(J).REAL+Rout(N-J).REAL+BR)*0.5
    Rout(J).IMAG=(Rout(J).IMAG-Rout(N-J).IMAG+BI)*0.5
    Rout(N-J).REAL=Rout(J).REAL-BR
    Rout(N-J).IMAG=BI-Rout(J).IMAG
!)    
    Rout(J).REAL=(tempVEC(J).REAL+tempVEC(N-J).REAL+BR)*0.25
    Rout(J).IMAG=(tempVEC(J).IMAG-tempVEC(N-J).IMAG+BI)*0.25
    Rout(N-J).REAL=Rout(J).REAL-BR*0.5
    Rout(N-J).IMAG=BI*0.5-Rout(J).IMAG
  FOR J=1 TO N>>1
END HFT

SUBROUTINE IFTU(type VARIABLE Rin^(*),Rout^(*))
  WITH BUF
  N=Rin.LENGTH
  IF LASTN MOD N # 0 THEN FFTSETUP(N)
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  tempVEC(0..Rin.HI)=Rin
  BTFLYI(tempVEC,N)
  POINTER INTO Rout R=1
  POINTER INTO tempVEC(0..Rin.HI) tv=1
  DO
    BT4I(tv(*),R(*))
    R=R+4
    tv=tv+4
  FOR N>>2 TIMES
END IFTU
  
SUBROUTINE FFTU(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH
  IF LASTN MOD N # 0 THEN FFTSETUP(N)
  Ninv=1/N
  POINTER INTO Rin R=1
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  POINTER INTO tempVEC(0..Rin.HI) tv=1
  DO
    BT4(tv(*),R(-1)*Ninv,R(0)*Ninv,R(1)*Ninv,R(2)*Ninv)
    R=R+4
    tv=tv+4
  FOR N>>2 TIMES
  BTFLY(tempVEC,N,4)
 Rout(*)=tempVEC
END FFTU

SUBROUTINE RFTU(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH BITAND -2
  IF LASTN MOD (2*N) # 0 THEN FFTSETUP(2*N)
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  tempVEC(0).REAL=Rin(0).REAL
  tempVEC(0).IMAG=Rin(0).REAL
  IF Rin.LENGTH BITAND 1 # 0 THEN
    tempVEC(0).REAL=~+Rin(N).REAL
    tempVEC(0).IMAG=~-Rin(N).REAL
  END IF
  POINTER INTO CEXP(LASTN DIV (N<<1)*(*)) C=0
  DO
    TYPEOF(Rin(0).REAL) AR,AI
    AR=Rin(J).REAL-Rin(N-J).REAL
    AI=Rin(J).IMAG+Rin(N-J).IMAG
    C=C+1
    BR=-C(0).IMAG*AR-C(0).REAL*AI
    BI=C(0).REAL*AR-C(0).IMAG*AI
    tempVEC(J).REAL=Rin(J).REAL+Rin(N-J).REAL+BR
    tempVEC(J).IMAG=Rin(J).IMAG-Rin(N-J).IMAG+BI
    tempVEC(N-J).REAL=tempVEC(J).REAL-BR-BR
    tempVEC(N-J).IMAG=BI+BI-tempVEC(J).IMAG
  FOR J=1 TO N>>1
  BTFLYI(tempVEC,N)
  POINTER INTO Rout R=1
  POINTER INTO tempVEC(0..Rin.HI) tv=1
  DO
    BT4I(tv(*),R(*))
    R=R+4
    tv=tv+4
  FOR N>>2 TIMES
END RFTU

SUBROUTINE HFTU(type VARIABLE Rin^(*), Rout^(*))
  WITH BUF
  N=Rin.LENGTH BITAND -2
  IF LASTN MOD (2*N) # 0 THEN FFTSETUP(2*N)
  POINTER TO ARRAY(0..Rin.HI) OF type tempVEC
  tempVEC=alloca[SIZEOF(tempVEC^)]
  tempVEC(0..N-1)=Rin
  BTFLY(tempVEC,N,1)
  Ninv=0.25/N
  Rout(0)=(tempVEC(0).REAL+tempVEC(0).IMAG)*2*Ninv
  IF Rout.LENGTH BITAND 1 # 0 THEN
    Rout(N)=Rout(0).REAL-tempVEC(0).IMAG
  END IF
  POINTER INTO CEXP(LASTN DIV (N<<1)*(*)) C=0
  DO
    AR=tempVEC(J).REAL-tempVEC(N-J).REAL
    AI=tempVEC(J).IMAG+tempVEC(N-J).IMAG
    C=C+1
    BR=-C(0).IMAG*AR+C(0).REAL*AI
    BI=-C(0).REAL*AR-C(0).IMAG*AI
    Rout(J).REAL=(tempVEC(J).REAL+tempVEC(N-J).REAL+BR)*Ninv
    Rout(J).IMAG=(tempVEC(J).IMAG-tempVEC(N-J).IMAG+BI)*Ninv
    Rout(N-J).REAL=Rout(J).REAL-BR*2*Ninv
    Rout(N-J).IMAG=BI*2*Ninv-Rout(J).IMAG
  FOR J=1 TO N>>1
END HFTU

END fft

POINTER TO REAL FUNCTION REALIFIED(POINTER TO ARRAY(*) OF COMPLEX x; INTEGER y)=
IF NOT ODD(y) THEN x(y RSHIFTED 1).REAL ELSE x(y RSHIFTED 1).IMAG

FRI SECTION
function "REALIFIED"]= 1["," fullsep] =[argument -> POINTER TO ARRAY * ARRAY =[ *]= =[argument -> INTEGER value =[{INTEGER value *]=^} -> =[function POINTER TO ARRAY #2 ARRAY #1 -> function =[{ *]=^}]= *]= -> =[function "REALIFIED" -> function =[function *]=
function "REALIFIED"]= 1["," fullsep] =[argument -> POINTER TO ARRAY * ARRAY =[{POINTER TO ARRAY *]=^} -> =[function "REALIFIED" -> function POINTER TO =[function POINTER TO ARRAY #1 *]= ]=
function "REALIFIED"]= 1["," fullsep] =[argument -> const POINTER TO ARRAY * ARRAY =[{POINTER TO ARRAY *]=^} -> =[function "REALIFIED" -> function POINTER TO =[function const POINTER TO ARRAY #1 *]= ]=
function "REALIFIED"]= 1["," fullsep] =[argument -> POINTER TO ARRAY { * } ^"," { * } {"COMPLEX_s"} type "COMPLEX" -> =[function POINTER TO ARRAY {: 1[const^const] ^"(" [--"," do asis] "," =[")*2"}{]= 1[const^const] ^"(" *]= =[")*2+1"}{"(signed)sizeof(double)"} REAL]= *]=
function "REALIFIED"]= 1["," fullsep] =[argument -> const POINTER TO ARRAY { * } ^"," { * } {"COMPLEX_s)"} type "COMPLEX" -> =[function const POINTER TO ARRAY {: 1[const^const] ^"(" [--"," do asis]"," =[")*2"}{]= 1[const^const] ^"(" *]= =[")*2+1"}{"(signed)sizeof(double)"} REAL]= *]=
END FRI SECTION
