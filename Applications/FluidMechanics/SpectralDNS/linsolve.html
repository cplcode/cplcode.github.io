<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>FluidMechanics/SpectralDNS/linsolve.cpl</title><meta name="description" content="CPL listing"><base href="https://CPLcode.net/Documentation/"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/singlecol.css"><style>pre{margin-left:0.5em;margin-right:0.5em} .comment{color:HotPink} a:link,a:visited{color:MediumBlue;text-decoration:none} a:hover,a:active{text-decoration:underline}</style>
<script type="application/ld+json">{
"@context":"http://schema.org",
"@type":"SoftwareSourceCode",
"name":"FluidMechanics/SpectralDNS/linsolve.cpl",
"programmingLanguage":{
"@type":"ComputerLanguage",
"name":"CPL",
"disambiguatingDescription":"Compiler and Programming Language Conceived by Paolo Luchini",
"url":"https://cplcode.net"}
}</script></head>
<body translate="no"><pre>
<span class=comment>! The following routines invert a pentadiagonal          [ d x x x x ]</span>
<span class=comment>! linear system with offset initial and final            [ x d x x x ]</span>
<span class=comment>! rows, compactly stored as in the scheme to             [ x x d x x ] </span>
<span class=comment>! the right, where "d" denotes diagonal elements.        [ x x d x x ] </span>
<span class=comment>! This allows the boundary conditions to be              [ --------- ]</span>
<span class=comment>! included in the same matrix as the differential        [ x x d x x ]</span>
<span class=comment>! equation without any additional storage.               [ x x d x x ]</span>
<span class=comment>! The routines are functionally equivalent to            [ x x x d x ]</span>
<span class=comment>! LUdecomp and \ from rbmat.cpl.                         [ x x x x d ]</span>

<a href="cpl.html#FUNCTION">SUBROUTINE</a> bcLUdecomp[<a href="cpl.html#POINTER">POINTER</a> <a href="cpl.html#TO">TO</a> <a href="cpl.html#ARRAY">ARRAY</a>(-1..ny+1,-2..2) <a href="cpl.html#OF">OF</a> <a href="cpl.html#REAL">REAL</a> A]
  <span class=comment>! eliminate (in the sense of Gauss) first and last two rows and then</span>
  <span class=comment>! invoke standard LUdecomp.</span>
  A(0,-1..<a href="cpl.html#HI">HI</a>)=<a href="cpl.html#Assignment">~</a>-A(0,-2)/A(-1,-2)&lowast;A(-1,-1..<a href="cpl.html#HI">HI</a>)
  A(1,-1..<a href="cpl.html#HI">HI</a>)=<a href="cpl.html#Assignment">~</a>-A(1,-2)/A(-1,-2)&lowast;A(-1,-1..<a href="cpl.html#HI">HI</a>)
  A(1,0..<a href="cpl.html#HI">HI</a>)=<a href="cpl.html#Assignment">~</a>-A(1,-1)/A(0,-1)&lowast;A(0,0..<a href="cpl.html#HI">HI</a>)
  A[2,-1+(0..<a href="cpl.html#HI">HI</a>)]=<a href="cpl.html#Assignment">~</a>-A(2,-2)/A(0,-1)&lowast;A(0,0..<a href="cpl.html#HI">HI</a>)
  A(ny,<a href="cpl.html#LO">LO</a>..1)=<a href="cpl.html#Assignment">~</a>-A(ny,2)/A(ny+1,2)&lowast;A(ny+1,<a href="cpl.html#LO">LO</a>..1)
  A(ny-1,<a href="cpl.html#LO">LO</a>..1)=<a href="cpl.html#Assignment">~</a>-A(ny-1,2)/A(ny+1,2)&lowast;A(ny+1,<a href="cpl.html#LO">LO</a>..1)
  A(ny-1,<a href="cpl.html#LO">LO</a>..0)=<a href="cpl.html#Assignment">~</a>-A(ny-1,1)/A(ny,1)&lowast;A(ny,<a href="cpl.html#LO">LO</a>..0)
  A[ny-2,1+(<a href="cpl.html#LO">LO</a>..0)]=<a href="cpl.html#Assignment">~</a>-A(ny-2,2)/A(ny,1)&lowast;A(ny,<a href="cpl.html#LO">LO</a>..0)
  LUdecomp A(1..ny-1)
<a href="cpl.html#END">END</a> bcLUdecomp

<a href="cpl.html#FUNCTION">SUBROUTINE</a> bcLeftDiv[<a href="cpl.html#POINTER">POINTER</a> <a href="cpl.html#TO">TO</a> <a href="cpl.html#ARRAY">ARRAY</a>(&lowast;) <a href="cpl.html#OF">OF</a> <a href="cpl.html#REAL">REAL</a> x; <a href="cpl.html#ARRAY">ARRAY</a>(-1..ny+1,-2..2) <a href="cpl.html#OF">OF</a> <a href="cpl.html#REAL">REAL</a> A]
<span class=comment>! notice: x cannot be declared with fixed size because it may be non-contiguous</span>
  x(0)=<a href="cpl.html#Assignment">~</a>-A(0,-2)/A(-1,-2)&lowast;x(-1)
  x(1)=<a href="cpl.html#Assignment">~</a>-A(1,-2)/A(-1,-2)&lowast;x(-1)
  x(1)=<a href="cpl.html#Assignment">~</a>-A(1,-1)/A(0,-1)&lowast;x(0)
  x(2)=<a href="cpl.html#Assignment">~</a>-A(2,-2)/A(0,-1)&lowast;x(0)
  x(ny)=<a href="cpl.html#Assignment">~</a>-A(ny,2)/A(ny+1,2)&lowast;x(ny+1)
  x(ny-1)=<a href="cpl.html#Assignment">~</a>-A(ny-1,2)/A(ny+1,2)&lowast;x(ny+1)
  x(ny-1)=<a href="cpl.html#Assignment">~</a>-A(ny-1,1)/A(ny,1)&lowast;x(ny)
  x(ny-2)=<a href="cpl.html#Assignment">~</a>-A(ny-2,2)/A(ny,1)&lowast;x(ny)
  x(1..ny-1)=A(1..ny-1)\~
  x(0)=-{A(0,0..2)&lowast;x[1+(0..2)]}/A(0,-1)
  x(-1)=-{A(-1,-1..2)&lowast;x[1+(-1..2)]}/A(-1,-2)
  x(ny)=-{A(ny,-2..0)&lowast;x[ny-1+(-2..0)]}/A(ny,1)
  x(ny+1)=-{A(ny+1,-2..1)&lowast;x[ny-1+(-2..1)]}/A(ny+1,2)
<a href="cpl.html#END">END</a> bcLeftDiv

<a href="cpl.html#ARRAY">ARRAY</a>(-1..ny+1,-2..2) <a href="cpl.html#OF">OF</a> <a href="cpl.html#REAL">REAL</a> D0mat=0, etamat=0, D2vmat=0
D0mat(1..ny-1)=derivatives.d0
D0mat(-1)=0; D0mat(-1,-2)=1; D0mat(0)=0; D0mat(0,-1)=1
D0mat(ny)=0; D0mat(ny,1)=1; D0mat(ny+1)=0; D0mat(ny+1,2)=1
bcLUdecomp D0mat
<a href="cpl.html#FUNCTION">SUBROUTINE</a> deriv(<a href="cpl.html#ARRAY">ARRAY</a>(&lowast;) <a href="cpl.html#OF">OF</a> <a href="cpl.html#REAL">REAL</a> f0,f1<a href="cpl.html#REAL-operator">^</a>)
  f1(0)=<a href="cpl.html#Looping-operator">SUM</a> d140(i)&lowast;f0(1+i) <a href="cpl.html#FOR">FOR</a> i=-2 <a href="cpl.html#TO">TO</a> 2
  f1(-1)=<a href="cpl.html#Looping-operator">SUM</a> d14m1(i)&lowast;f0(1+i) <a href="cpl.html#FOR">FOR</a> i=-2 <a href="cpl.html#TO">TO</a> 2
  f1(ny)=<a href="cpl.html#Looping-operator">SUM</a> d14n(i)&lowast;f0(ny-1+i) <a href="cpl.html#FOR">FOR</a> i=-2 <a href="cpl.html#TO">TO</a> 2
  f1(ny+1)=<a href="cpl.html#Looping-operator">SUM</a> d14np1(i)&lowast;f0(ny-1+i) <a href="cpl.html#FOR">FOR</a> i=-2 <a href="cpl.html#TO">TO</a> 2
  <a href="cpl.html#DO">DO</a> <a href="cpl.html#WITH">WITH</a> derivatives(i) f1(i)=D1(f0(i+(&lowast;))) <a href="cpl.html#FOR">FOR</a> i=1 <a href="cpl.html#TO">TO</a> ny-1
  bcLeftDiv(f1,D0mat)
<a href="cpl.html#END">END</a> deriv

<a href="cpl.html#FUNCTION">SUBROUTINE</a> linsolve(<a href="cpl.html#REAL">REAL</a> lambda)
  <a href="cpl.html#LOOP">LOOP</a> <a href="cpl.html#FOR">FOR</a> <a href="cpl.html#ALL">ALL</a> ix,iz
  ialpha=I&lowast;alpha0&lowast;ix; ibeta=I&lowast;beta0&lowast;iz
  k2=(alpha0&lowast;ix)<a href="cpl.html#compound-index">**</a>2+(beta0&lowast;iz)<a href="cpl.html#compound-index">**</a>2
  <a href="cpl.html#LOOP">LOOP</a> <a href="cpl.html#FOR">FOR</a> iy=1 <a href="cpl.html#TO">TO</a> ny-1 <a href="cpl.html#WITH">WITH</a> derivatives(iy)
    <a href="cpl.html#DO">DO</a> D2vmat(iy,i)=lambda&lowast;[d2(i)-k2&lowast;d0(i)]-OS(i) <a href="cpl.html#FOR">FOR</a> <a href="cpl.html#ALL">ALL</a> i
    <a href="cpl.html#DO">DO</a> etamat(iy,i)=lambda&lowast;d0(i)-SQ(i) <a href="cpl.html#FOR">FOR</a> <a href="cpl.html#ALL">ALL</a> i
  <a href="cpl.html#LOOP">REPEAT</a>
  <span class=comment>! boundary conditions</span>
  D2vmat(0)=d040; D2vmat(-1)=d140
  D2vmat(ny)=d04n; D2vmat(ny+1)=d14n
  etamat(0)=d040; etamat(-1)=derivatives(1).d4
  etamat(ny)=d04n; etamat(ny+1)=derivatives(ny-1).d4
  bcLUdecomp D2vmat; bcLUdecomp etamat
  <a href="cpl.html#WITH">WITH</a> V(ix,iz,&lowast;):
  v(0)=0;  v(-1)=0; v(ny)=0; v(ny+1)=0
  bcLeftDiv(v.<a href="cpl.html#REAL">REAL</a>,D2vmat); bcLeftDiv(v.<a href="complex.html#Top">IMAG</a>,D2vmat)
  u(0)=0; u(-1)=0;  u(ny)=0; u(ny+1)=0
  bcLeftDiv(u.<a href="cpl.html#REAL">REAL</a>,etamat); bcLeftDiv(u.<a href="complex.html#Top">IMAG</a>,etamat)
  <a href="cpl.html#IF">IF</a> ix=0 <a href="cpl.html#AND">AND</a> iz=0 <a href="cpl.html#IF">THEN</a>
    w=u.<a href="complex.html#Top">IMAG</a>; u.<a href="complex.html#Top">IMAG</a>=0
    <a href="cpl.html#IF">IF</a> <a href="cpl.html#ABS">ABS</a>(meanflowx)&gt;1E-10 <a href="cpl.html#OR">OR</a> <a href="cpl.html#ABS">ABS</a>(meanflowz)&gt;1E-10 <a href="cpl.html#IF">THEN</a>
      <a href="cpl.html#REAL">REAL</a> ucor(-1..ny+1); <a href="cpl.html#DO">DO</a> ucor(iy)=1 <a href="cpl.html#FOR">FOR</a> iy=1 <a href="cpl.html#TO">TO</a> ny-1
      ucor(0)=0; ucor(-1)=0; ucor(ny)=0; ucor(ny+1)=0
      bcLeftDiv(ucor,etamat)
      <a href="cpl.html#IF">IF</a> <a href="cpl.html#ABS">ABS</a>(meanflowx)&gt;1E-10 <a href="cpl.html#IF">THEN</a> u.<a href="cpl.html#REAL">REAL</a>=<a href="cpl.html#Assignment">~</a>+(meanflowx-yintegr(u.<a href="cpl.html#REAL">REAL</a>))/yintegr(ucor)&lowast;ucor
      <a href="cpl.html#IF">IF</a> <a href="cpl.html#ABS">ABS</a>(meanflowz)&gt;1E-10 <a href="cpl.html#IF">THEN</a> v.<a href="cpl.html#REAL">REAL</a>=<a href="cpl.html#Assignment">~</a>+(meanflowz-yintegr(v.<a href="cpl.html#REAL">REAL</a>))/yintegr(ucor)&lowast;ucor
    <a href="cpl.html#END">END</a> <a href="cpl.html#IF">IF</a>
  <a href="cpl.html#ELSE">ELSE</a>
    deriv(v.<a href="cpl.html#REAL">REAL</a>,w.<a href="cpl.html#REAL">REAL</a>); deriv(v.<a href="complex.html#Top">IMAG</a>,w.<a href="complex.html#Top">IMAG</a>)
    <a href="cpl.html#DO">DO</a> temp=(ialpha&lowast;w(iy)-ibeta&lowast;u(iy))/k2
      w(iy)=(ibeta&lowast;w(iy)+ialpha&lowast;u(iy))/k2 
      u(iy)=temp
    <a href="cpl.html#FOR">FOR</a> iy=-1 <a href="cpl.html#TO">TO</a> ny+1
  <a href="cpl.html#END">END</a> <a href="cpl.html#IF">IF</a>
<a href="cpl.html#LOOP">REPEAT</a>
<a href="cpl.html#END">END</a> linsolve
</pre></body></html>
