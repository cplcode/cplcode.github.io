<!DOCTYPE html>
<html lang=en>
<head>
  <title>CPL Reference Manual</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="author" content="Paolo Luchini">
  <meta name="copyright" content="Copyright 2001-2020 Paolo Luchini">
  <meta name="description" content="Language reference for CPL, a programming language designed and developed by Paolo Luchini during 1993-2020. Documentation and distribution offered for download includes a compiler, interpreter and text editor.">
  <meta name="keywords" content="cpl CPL numerical computation computational code program programmer programming language compiler interpreter editor fri FRI makecpl icpl edit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../singlecol.css">
  <style>
    .page {
      display:none;
    }
    .page:target {
      display: block;
      white-space: pre-wrap;
      }
    th {
      text-align:left;
    }
  </style>
<link rel="canonical" href="https://CPLcode.net/Documentation/cpl.html#Top">
</head>
<body><a href="../"><img id=seal src="../images/CPL-logo.png" alt="CPL"></a><div>
</div><div class=page id="Top">
Node: (cpl)Top,  Next: <a href="#Keyword%20Index">Keyword Index</a>, Up: <a href="../">CPLcode.net</a>
<hr>
This is the documentation for the CPL programming language and its compiler,
as of December 2020.

CPL = Concealed Pointer Lookup
CPL = Custom Parameter Lists
CPL = Consistent Procedure Linkage
CPL = Compiled Programming Language
CPL = Conceived by Paolo Luchini

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#Installation">Installation</a>:</td><td>Directory structure</td></tr>
<tr><td><a href="#Syntax">Syntax</a>:</td><td>Language syntax overview</td></tr>
<tr><td><a href="#Functions">Functions</a>:</td><td>Functions and subroutines</td></tr>
<tr><td><a href="#Declarations">Declarations</a>:</td><td>Variable, type and constant declarations</td></tr>
<tr><td><a href="#Statements">Statements</a>:</td><td>Executable statements and expressions</td></tr>
<tr><td><a href="#Control">Control</a>:</td><td>Program flow control statements</td></tr>
<tr><td><a href="#makecpl">makecpl</a>:</td><td>Compilation tools and their usage</td></tr>
<tr><td><a href="#icpl">icpl</a>:</td><td>Interactive CPL</td></tr>
<tr><td><a href="#Library">Library</a>:</td><td>Ready to USE library of CPL modules</td></tr>
</table></nav>
</div><div class=page id="Keyword%20Index">
Node: (cpl)Keyword Index,  Next: <a href="#Installation">Installation</a>,  Prev: <a href="#Top">Top</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Keyword index</h1>

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#ABS">ABS</a>:</td><td>absolute value</td></tr>
<tr><td><a href="#ALL">ALL</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#AND">AND</a>:</td><td>boolean AND</td></tr>
<tr><td><a href="#ARRAY">ARRAY</a>:</td><td>subscripted arrays</td></tr>
<tr><td><a href="#ASK">ASK</a>:</td><td>console prompting and reading</td></tr>
<tr><td><a href="#Builtin">ATAN:Builtin</a>:</td><td>arctangent</td></tr>
<tr><td><a href="#BINARY">BINARY</a>:</td><td>binary format input/output</td></tr>
<tr><td><a href="#Bitwise">BITAND:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="#Bitwise">BITNOT:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="#Bitwise">BITOR:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="#Bitwise">BITXOR:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="#BOOLEAN">BOOLEAN</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#BY">BY</a>:</td><td>used in FOR, READ, WRITE</td></tr>
<tr><td><a href="#C%20SECTION">C SECTION</a>:</td><td>transparent C source code inclusion</td></tr>
<tr><td><a href="#CASE">CASE</a>:</td><td>multiple-choice selection</td></tr>
<tr><td><a href="#CASE%20LOOP">CASE LOOP</a>:</td><td>multiple-choice loop</td></tr>
<tr><td><a href="#CEILING">CEILING</a>:</td><td>larger or equal integer</td></tr>
<tr><td><a href="#CHAR">CHAR</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#CHARbyCHAR">CHARbyCHAR</a>:</td><td>live keyboard input</td></tr>
<tr><td><a href="#COMMANDLINE">COMMANDLINE</a>:</td><td>command line parameter access</td></tr>
<tr><td><a href="#CONSTANT">CONSTANT</a>:</td><td>value which cannot be altered later in the program</td></tr>
<tr><td><a href="#Builtin">COS:Builtin</a>:</td><td>cosine</td></tr>
<tr><td><a href="#CREATE">CREATE</a>:</td><td>open a buffered file of zero length</td></tr>
<tr><td><a href="#WRITE">DEFAULTFORMAT:WRITE</a>:</td><td>default format</td></tr>
<tr><td><a href="#INTEGER%20operator">DIV:INTEGER operator</a>:</td><td></td></tr>
<tr><td><a href="#DO">DO</a>:</td><td>conditional and sequential loops</td></tr>
<tr><td><a href="#FOR">DOWN:FOR</a>:</td><td>Loop with decreasing index</td></tr>
<tr><td><a href="#ELSE">ELSE</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#END">END</a>:</td><td>ends a block</td></tr>
<tr><td><a href="#Builtin">EOF:Builtin</a>:</td><td>test for end of file</td></tr>
<tr><td><a href="#ERROR">ERROR</a>:</td><td>signal an error and exit or trigger a TRAP</td></tr>
<tr><td><a href="#TRAP">ERRORMESSAGE:TRAP</a>:</td><td>error message string</td></tr>
<tr><td><a href="#EXCEPT">EXCEPT</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#EXIT">EXIT</a>:</td><td>exit from loop, module or subroutine</td></tr>
<tr><td><a href="#Builtin">EXP:Builtin</a>:</td><td>exponential</td></tr>
<tr><td><a href="#BOOLEAN">FALSE:BOOLEAN</a>:</td><td>value</td></tr>
<tr><td><a href="#FILE">FILE</a>:</td><td>buffered file-descriptor type</td></tr>
<tr><td><a href="#FLOOR">FLOOR</a>:</td><td>smaller or equal integer</td></tr>
<tr><td><a href="#FLUSH">FLUSH</a>:</td><td>flush a file's write buffer</td></tr>
<tr><td><a href="#FOLLOWS">FOLLOWS</a>:</td><td>Function prototypes</td></tr>
<tr><td><a href="#FOR">FOR</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#FORTRAN%20interface">FORTRANCALL:FORTRAN interface</a>:</td><td></td></tr>
<tr><td><a href="#FORTRAN%20interface">FORTRANFUNCTION:FORTRAN interface</a>:</td><td></td></tr>
<tr><td><a href="#FREE">FREE</a>:</td><td>release dynamically allocated memory or file</td></tr>
<tr><td><a href="#FRI%20SECTION">FRI SECTION</a>:</td><td>dynamic extension of the language</td></tr>
<tr><td><a href="#FROM">FROM</a>:</td><td>used in READ statements</td></tr>
<tr><td><a href="#FUNCTION">FUNCTION</a>:</td><td>Function declaration</td></tr>
<tr><td><a href="#GAUSS">GAUSS</a>:</td><td>gaussian distributed random REAL number with variance 1</td></tr>
<tr><td><a href="#HI">HI</a>:</td><td>upper bound of an array index</td></tr>
<tr><td><a href="#HI">HI1:HI</a>:</td><td></td></tr>
<tr><td><a href="#HI">HI2:HI</a>:</td><td></td></tr>
<tr><td><a href="#HI">HI3:HI</a>:</td><td></td></tr>
<tr><td><a href="#IF">IF</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#IN">IN</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#INCLUDE">INCLUDE</a>:</td><td>source file inclusion</td></tr>
<tr><td><a href="#INLINE">INLINE</a>:</td><td>Subroutines or functions as macros</td></tr>
<tr><td><a href="#INPUTREADY">INPUTREADY</a>:</td><td>test for input ready on a file descriptor or stdin</td></tr>
<tr><td><a href="#INTEGER">INTEGER</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#INTO">INTO</a>:</td><td>Pointer arithmetics</td></tr>
<tr><td><a href="#IS">IS</a>:</td><td>type comparison operator</td></tr>
<tr><td><a href="#LENGTH">LENGTH</a>:</td><td>number of elements of an array</td></tr>
<tr><td><a href="#LO">LO</a>:</td><td>lower bound of an array index</td></tr>
<tr><td><a href="#LO">LO1:LO</a>:</td><td></td></tr>
<tr><td><a href="#LO">LO2:LO</a>:</td><td></td></tr>
<tr><td><a href="#LO">LO3:LO</a>:</td><td></td></tr>
<tr><td><a href="#Builtin">LOG:Builtin</a>:</td><td>logarithm</td></tr>
<tr><td><a href="#LOOP">LOOP</a>:</td><td>conditional and sequential loops</td></tr>
<tr><td><a href="#Bitwise">LSHIFTED:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="#MAX">MAX</a>:</td><td>maximum value function or looping operator</td></tr>
<tr><td><a href="#MAXABS">MAXABS</a>:</td><td>maximum absolute value</td></tr>
<tr><td><a href="#MIN">MIN</a>:</td><td>minimum value function or looping operator</td></tr>
<tr><td><a href="#MOD">MOD</a>:</td><td>INTEGER modulo operator or ARRAY modulus</td></tr>
<tr><td><a href="#MODULE">MODULE</a>:</td><td>separately scoped program block</td></tr>
<tr><td><a href="#NAME">NAME</a>:</td><td>writing and reading a variable's name</td></tr>
<tr><td><a href="#NEW">NEW</a>:</td><td>dynamically allocate temporary memory space or file</td></tr>
<tr><td><a href="#BOOLEAN">NO:BOOLEAN</a>:</td><td>value</td></tr>
<tr><td><a href="#NORM">NORM</a>:</td><td>squared absolute value</td></tr>
<tr><td><a href="#NOT">NOT</a>:</td><td>boolean NOT</td></tr>
<tr><td><a href="#POINTER">NULL:POINTER</a>:</td><td></td></tr>
<tr><td><a href="#DYNAMIC">DYNAMIC</a>:</td><td>object-oriented features</td></tr>
<tr><td><a href="#Builtin">ODD:Builtin</a>:</td><td>test for odd number</td></tr>
<tr><td><a href="#OF">OF</a>:</td><td>used in ARRAY and CASE</td></tr>
<tr><td><a href="#OPEN">OPEN</a>:</td><td>open a file and associate a buffered file descriptor</td></tr>
<tr><td><a href="#OPTIONAL">OPTIONAL</a>:</td><td>optional function parameters recognized by name</td></tr>
<tr><td><a href="#OR">OR</a>:</td><td>boolean OR</td></tr>
<tr><td><a href="parallel.html#Top">PARALLEL MODULE:(parallel)</a>:</td><td>Forking a parallel process</td></tr>
<tr><td><a href="parallel.html#Top">PARALLEL LOOP:(parallel)</a>:</td><td>Simultaneous multiple processes</td></tr>
<tr><td><a href="#POINTER">POINTER</a>:</td><td>pointer to a memory address</td></tr>
<tr><td><a href="#POSITION">POSITION</a>:</td><td>read or set a file's current position</td></tr>
<tr><td><a href="#Looping%20operator">PRODUCT:Looping operator</a>:</td><td></td></tr>
<tr><td><a href="#PROMPT">PROMPT</a>:</td><td>terminal input prompt</td></tr>
<tr><td><a href="#RAND">RAND</a>:</td><td>uniformly distributed in (0,1) random REAL number</td></tr>
<tr><td><a href="#READ">READ</a>:</td><td>input from character files and devices</td></tr>
<tr><td><a href="#REAL">REAL</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="graphics.html#gnuplot">REALTABLE:(graphics)gnuplot</a>:</td><td>read matrix from table file</td></tr>
<tr><td><a href="#LOOP">REPEAT:LOOP</a>:</td><td></td></tr>
<tr><td><a href="#FUNCTION">RESULT:FUNCTION</a>:</td><td></td></tr>
<tr><td><a href="#FUNCTION">RETURN:FUNCTION</a>:</td><td></td></tr>
<tr><td><a href="#ROUND">ROUND</a>:</td><td>nearest integer</td></tr>
<tr><td><a href="#Bitwise">RSHIFTED:Bitwise</a>:</td><td>boolean operator</td></tr>
<tr><td><a href="parallel.html#Top">SHARED:(parallel)</a>:</td><td>Shared memory among parallel processes</td></tr>
<tr><td><a href="#Builtin">SIN:Builtin</a>:</td><td>sine</td></tr>
<tr><td><a href="#SINGLE">SINGLE</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#TYPE">SIZEOF:TYPE</a>:</td><td>memory occupation</td></tr>
<tr><td><a href="#Builtin">SQRT:Builtin</a>:</td><td>square root</td></tr>
<tr><td><a href="#STOP">STOP</a>:</td><td>stop the program</td></tr>
<tr><td><a href="#STORED">STORED</a>:</td><td>random-access files as disk-resident variables</td></tr>
<tr><td><a href="#FORTRAN%20interface">STRIDEOF:FORTRAN interface</a>:</td><td></td></tr>
<tr><td><a href="#STRING">STRING</a>:</td><td>strings of characters</td></tr>
<tr><td><a href="#STRUCTURE">STRUCTURE</a>:</td><td>compound variables</td></tr>
<tr><td><a href="#STRUCTURED">STRUCTURED</a>:</td><td>ARRAY     may appear as both a structure and an array</td></tr>
<tr><td><a href="#SUBROUTINE">SUBROUTINE</a>:</td><td>Subroutine declaration</td></tr>
<tr><td><a href="#Looping%20operator">SUM:Looping operator</a>:</td><td></td></tr>
<tr><td><a href="graphics.html#gnuplot">TABLE:(graphics)gnuplot</a>:</td><td>WRITE TABLE to file using plot syntax</td></tr>
<tr><td><a href="#Builtin">TAN:Builtin</a>:</td><td>tangent</td></tr>
<tr><td><a href="#IF">THEN:IF</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#TIMES">TIMES</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#TO">TO</a>:</td><td>used in POINTER, WRITE, FOR</td></tr>
<tr><td><a href="#TRACE">TRACE</a>:</td><td>ON/OFF         turns execution tracing on/off.</td></tr>
<tr><td><a href="#TRACE">TROFF:TRACE</a>:</td><td>turns execution tracing off.</td></tr>
<tr><td><a href="#TRACE">TRON:TRACE</a>:</td><td>turns execution tracing on.</td></tr>
<tr><td><a href="#subarray">TRANSPOSED:subarray</a>:</td><td>operation to transpose a matrix</td></tr>
<tr><td><a href="#TRAP">TRAP</a>:</td><td>error handling</td></tr>
<tr><td><a href="#BOOLEAN">TRUE:BOOLEAN</a>:</td><td>value</td></tr>
<tr><td><a href="#TYPE">TYPE</a>:</td><td>declaration of a new type identifier</td></tr>
<tr><td><a href="#TYPE">TYPEOF:TYPE</a>:</td><td>extraction pseudo-function</td></tr>
<tr><td><a href="#UNTIL">UNTIL</a>:</td><td>loop terminating condition</td></tr>
<tr><td><a href="#USE">USE</a>:</td><td>separately compiled modules</td></tr>
<tr><td><a href="#VARIABLE">VARIABLE</a>:</td><td>can be re-assigned multiple times</td></tr>
<tr><td><a href="#WHILE">WHILE</a>:</td><td>loop continuation condition</td></tr>
<tr><td><a href="#WITH">WITH</a>:</td><td>implicit access to structure fields and functions</td></tr>
<tr><td><a href="#WRITE">WRITE</a>:</td><td>output to character files and devices</td></tr>
<tr><td><a href="graphics.html#gnuplot">WRITE TABLE:(graphics)gnuplot</a>:</td><td>write table to file using plot syntax</td></tr>
<tr><td><a href="#BOOLEAN">YES:BOOLEAN</a>:</td><td>value</td></tr>
<tr><td><a href="matrix.html#Top">cbmat:(matrix)</a>:</td><td>Complex square and Banded Matrix operations</td></tr>
<tr><td><a href="#icpl">clear:icpl</a>:</td><td>remove variable and its associated storage</td></tr>
<tr><td><a href="complex.html#Top">complex:(complex)</a>:</td><td>Complex numbers</td></tr>
<tr><td><a href="#cpl">cpl</a>:</td><td>The CPL-to-C compiler</td></tr>
<tr><td><a href="editor.html#full-screen">edit:(editor)full-screen</a>:</td><td>Open an existing or new file in full-screen editor</td></tr>
<tr><td><a href="#icpl">exit:icpl</a>:</td><td>quit icpl</td></tr>
<tr><td><a href="fft.html#Top">fft:(fft)</a>:</td><td>Fast Fourier Transforms</td></tr>
<tr><td><a href="#fri">fri</a>:</td><td>The Formal Rule Interpreter</td></tr>
<tr><td><a href="graphics.html#gnuplot">gnuplot:(graphics)gnuplot</a>:</td><td>plotting primitives rendered through gnuplot</td></tr>
<tr><td><a href="graphics.html#Top">graphics:(graphics)</a>:</td><td>plotting primitives using GNU plotutils</td></tr>
<tr><td><a href="#icpl">icpl</a>:</td><td>Interactive CPL</td></tr>
<tr><td><a href="#command%20interpretation">icpl:command interpretation</a>:</td><td>of a run-time generated CPL statement</td></tr>
<tr><td><a href="#infocpl">infocpl</a>:</td><td>info reading script</td></tr>
<tr><td><a href="#lapack-eigv">lapack-eigv</a>:</td><td>interface to LAPACK matrix eigenvalue routines</td></tr>
<tr><td><a href="#STRING">literal:STRING</a>:</td><td>constant string of characters</td></tr>
<tr><td><a href="editor.html#full-screen">load:(editor)full-screen</a>:</td><td>Load a file at current cursor position</td></tr>
<tr><td><a href="#makecpl">makecpl</a>:</td><td>Compilation tools and their usage</td></tr>
<tr><td><a href="#Nested%20functions">nested:Nested functions</a>:</td><td>are allowed wherever a declaration is.</td></tr>
<tr><td><a href="graphics.html#nographics">nographics:(graphics)nographics</a>:</td><td>fake plotting package (does nothing)</td></tr>
<tr><td><a href="parallel.html#nonparallel">nonparallel:(parallel)nonparallel</a>:</td><td>fake parallel package (does nothing)</td></tr>
<tr><td><a href="parallel.html#Top">parallel:(parallel)</a>:</td><td>Parallel computing</td></tr>
<tr><td><a href="graphics.html#gnuplot">plot:(graphics)gnuplot</a>:</td><td>gnuplot plot command with CPL arguments</td></tr>
<tr><td><a href="#icpl">quit:icpl</a>:</td><td>exit icpl</td></tr>
<tr><td><a href="matrix.html#Top">rbmat:(matrix)</a>:</td><td>Real square and Banded Matrix operations</td></tr>
<tr><td><a href="editor.html#Top">readline:(editor)</a>:</td><td>Own implementation of readline input editor</td></tr>
<tr><td><a href="#rtchecks">rtchecks</a>:</td><td>.                Run Time bounds Checking</td></tr>
<tr><td><a href="editor.html#full-screen">save:(editor)full-screen</a>:</td><td>Save the session log or current screen to a file</td></tr>
<tr><td><a href="graphics.html#gnuplot">set:(graphics)gnuplot</a>:</td><td>set command for gnuplot, passed as is </td></tr>
<tr><td><a href="strlines.html#Top">strlines:(strlines)</a>:</td><td>Streamline plotting</td></tr>
<tr><td><a href="symbolic.html#Top">symbolic:(symbolic)</a>:</td><td>Symbolic differentiation</td></tr>
<tr><td><a href="#ARRAY">*:ARRAY</a>:</td><td>or multiplication operator</td></tr>
<tr><td><a href="#compound%20index">**:compound index</a>:</td><td>Also alternate power operator</td></tr>
<tr><td><a href="#Assignment">=:Assignment</a>:</td><td>Also comparison operator</td></tr>
<tr><td><a href="#Delayed%20assignment">==:Delayed assignment</a>:</td><td></td></tr>
<tr><td><a href="#REAL%20operator">^:REAL operator</a>:</td><td>or postfix POINTER dereference</td></tr>
<tr><td><a href="#Assignment">~:Assignment</a>:</td><td>place-holder for the l.h.s.</td></tr>
<tr><td><a href="#C%20SECTION">&lt;*:C SECTION</a>:</td><td></td></tr>
<tr><td><a href="#STRING">&lt;&lt;:STRING</a>:</td><td></td></tr>
<tr><td><a href="#Comparison">#:Comparison</a>:</td><td></td></tr>
<tr><td><a href="#C%20preprocessor">#define:C preprocessor</a>:</td><td></td></tr>
<tr><td><a href="#C%20preprocessor">#else:C preprocessor</a>:</td><td></td></tr>
<tr><td><a href="#C%20preprocessor">#endif:C preprocessor</a>:</td><td></td></tr>
<tr><td><a href="#C%20preprocessor">#if:C preprocessor</a>:</td><td></td></tr>
<tr><td><a href="#C%20interface">#include:C interface</a>:</td><td></td></tr>
<tr><td><a href="#C%20interface">#includedir:C interface</a>:</td><td></td></tr>
<tr><td><a href="#C%20interface">#link:C interface</a>:</td><td></td></tr>
<tr><td><a href="#C%20preprocessor">#undef:C preprocessor</a>:</td><td></td></tr>
<tr><td><a href="#Einstein%20convention">$:Einstein convention</a>:</td><td></td></tr>
<tr><td><a href="#Comments">!:Comments</a>:</td><td></td></tr>
<tr><td><a href="#?">?</a>:</td><td>icpl help</td></tr>
<tr><td><a href="#Top"></a>:</td><td>:                        icpl shell command</td></tr>
<tr><td><a href="#$">$</a>:</td><td>icpl last result</td></tr>
</table></nav>
</div><div class=page id="Installation">
Node: (cpl)Installation, Next: <a href="#Syntax">Syntax</a>, Prev: <a href="#Keyword%20Index">Keyword Index</a>, Up: <a href="#Top">Top</a>
<hr>

<h1>Installation</h1>

This is CPL, a high-level programming language designed and developed by Paolo
Luchini for his own use and his collaborators' during 1993-2020.

The files that compose the CPL system are located in their own directory,
separate from user programs, and can be shared among users. This directory is
preferably named /usr/local/fri in a shared installation or ~/fri in a single
user's space, but any other name can be used as well. None of the tools require
root privileges nor write permission; it suffices that they be readable and
executable by every interested user.

Once the directory is created and contains the appropriate files, you should cd
to it and run setup (cpl.sh already does this for you). setup (or "sh setup"
if this file's executable flag is not turned on) should be run again every time
modifications or updates are made.

Documentation in info format can be read through the script "infocpl", or by
starting the cpl interpreter "icpl" (if installed) and typing the command "?".
Typing "infocpl &lt;keyword&gt;" brings you help about a given CPL keyword.
</div><div class=page id="Syntax">
Node: (cpl)Syntax,  Next: <a href="#Functions">Functions</a>,  Prev: <a href="#Installation">Installation</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>The CPL programming language syntax</h1>

CPL = Concealed Pointer Lookup
CPL = Custom Parameter Lists
CPL = Consistent Procedure Linkage
CPL = Computer Programming Language
CPL = Conceived by Paolo Luchini

A CPL <a href="#Source%20file">Source file</a> is composed of nested blocks of statements which
take effect in a hierarchical top-down order, much like Pascal or Modula-2.
Statements are composed of keywords (<a href="#Keyword%20index">Keyword index</a>), identifiers and
separators.

User-declared identifiers can contain alphabetic and numeric characters plus
"_" and can be of any length. Upper and lower case are considered distinct. The
first character of an identifier must be non-numeric.

Separators can be spaces, tabs or comments (<a href="#Comments">Comments</a>) in any number and
sequence; at least one separator is required between contiguous words that
could otherwise be mistaken for a single identifier.

Statements within a block are delimited by either newline or ";", which allows
for multi-statement lines without requiring (but permitting) a ";" when the
statement ends at the end of a line. Multi-line statements can be broken
wherever the statement is incomplete: if the given line does not make sense as
is, the compiler will automatically treat newline as a separator and try to
complete the statement on the next line. Continuation can also be explicitly
requested wherever a separator is allowed by putting a "\" as the last
character before newline.

Round, square and curly brackets can be used interchangeably wherever a
parenthesis is needed, in either declarations, statements or expressions.
(<a href="#Parentheses">Parentheses</a>)

Subroutine and function declarations (<a href="#Functions">Functions</a>) are on the same
footing as all other <a href="#VARIABLE">VARIABLE</a>, <a href="#CONSTANT">CONSTANT</a> and <a href="#TYPE">TYPE</a>
declarations. Contrary to many other languages, declarations (<a href="#Declarations">
Declarations</a>) and executable statements (<a href="#Statements">Statements</a>) may be freely
intermixed in the program flow. The scope of a declaration extends from the
position where the declaration appears down to the end of the containing block.
It is recommended that declarations appear as close as possible to the position
where the declared item is used for the first time, as this enables the
compiler to catch a larger number of errors automatically. In most situations,
a variable can be declared and initialized in a single statement.

CPL has Custom Parameter Lists, meaning that not just commas but any
non-ambiguous single character or character sequence may be used as parameter
separators in function calls. (<a href="#Functions">Custom Parameter Lists:Functions</a>) Whereas
commas will still be the commonest choice for short parameter lists, a
remindful choice of separators can make long parameter lists both more
understandable and more thoroughly checked by the compiler. Parameters may also
be <a href="#OPTIONAL">OPTIONAL</a>, and be specified by name rather than by position.

Loops and all other flow control statements (<a href="#Control">Control</a>) implicitly define
new blocks within them, just as subroutine declarations do. A block can also be
explicitly delimited as a <a href="#MODULE">MODULE</a>. A block can contain every declaration
that the outermost block can, including further subroutines and modules, but
the declared items cease to exist on exit from the block.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#Comments">Comments</a>:</td><td>syntax for comments</td></tr>
<tr><td><a href="#Parentheses">Parentheses</a>:</td><td>Round, square and curly brackets</td></tr>
<tr><td><a href="#C%20preprocessor">C preprocessor</a>:</td><td>macro definition and conditional compilation</td></tr>
<tr><td><a href="#Source%20file">Source file</a>:</td><td>format and inclusion</td></tr>
<tr><td><a href="#MODULE">MODULE</a>:</td><td>separately scoped program block</td></tr>
<tr><td><a href="#Functions">Functions</a>:</td><td>Functions and subroutines</td></tr>
<tr><td><a href="#Declarations">Declarations</a>:</td><td>Variable, constant and type declarations</td></tr>
<tr><td><a href="#Statements">Statements</a>:</td><td>Executable statements and expressions</td></tr>
<tr><td><a href="#Control">Control</a>:</td><td>Program flow control statements</td></tr>
</table></nav>
</div><div class=page id="Comments">
Node: (cpl)Comments,  Next: <a href="#Parentheses">Parentheses</a>,  Prev: <a href="#Syntax">Syntax</a>,  Up: <a href="#Syntax">Syntax</a>
<hr>

<h2>Comments</h2>

Comments delimited by ! without a following bracket extend to the end of line.

Comments delimited by !( ... !) or ![ ... !] or !{ ... !} can be inserted
wherever a space can, and can extend over a few characters or over several
lines. The compiler will still match !bracket pairs within comments, and
consider the comment finished only when all opened parentheses have been
closed.
</div><div class=page id="Parentheses">
Node: (cpl)Parentheses, Next: <a href="#C%20preprocessor">C preprocessor</a>, Prev: <a href="#Comments">Comments</a>, Up: <a href="#Syntax">Syntax</a>
<hr>

<h2>Parentheses</h2>

Round, square and curly brackets can all be used interchangeably wherever a
parenthesis is needed, but the compiler requires that every opening bracket is
closed by a matching bracket of the same kind, just as in mathematics.
Alternating the three kinds of bracket, while not mandatory, makes for easier
reading by the programmer and more effective error catching by the compiler.

When round brackets are used in the statement prototypes contained in this
manual, it is always understood that the other two styles may be used as
well. In such prototypes square brackets denote optional items.
</div><div class=page id="C%20preprocessor">
Node: (cpl)C preprocessor, Next: <a href="#Source%20file">Source file</a>, Prev: <a href="#Parentheses">Parentheses</a>, Up: <a href="#Syntax">Syntax</a>
<hr>

<h2>Macro definition and conditional compilation</h2>

C preprocessor #define and #if constructs (<a href="#(/usr/share/info/cpp">:(/usr/share/info/cpp</a>).)
are used in a CPL program to define macros and alter the flow of compilation.
For file inclusion see <a href="#USE">USE</a>, <a href="#INCLUDE">INCLUDE</a>, and <a href="#C%20interface">C interface</a>. 
</div><div class=page id="Source%20file">
Node: (cpl)Source file, Next: <a href="#MODULE">MODULE</a>, Prev: <a href="#C%20preprocessor">C preprocessor</a>, Up: <a href="#Syntax">Syntax</a>
<hr>

<h2>Source files</h2>

A CPL program file directly consists of a sequential block of declarations and
statements, some of which may in turn contain other blocks, without any need to
mark the beginning and end of the complete program other than by the beginning
and end of the file itself. Optionally the statement

        USE cpl
        
may appear as the first line. <a href="#fri">USE cpl:fri</a>.

The standard ending for CPL source files is .cpl, and is automatically added by
the compiler if omitted. Though this ending is unambiguous in unix, it does
have a small inconvenience in being banned from some email services because
of malicious exploitation in Microsoft Windows Control PaneL files. If you
encounter this problem, just rename your .cpl files to some other ending before
sending them as email attachments.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#USE">USE</a>:</td><td>Separately compiled program segments</td></tr>
<tr><td><a href="#INCLUDE">INCLUDE</a>:</td><td>File inclusion</td></tr>
<tr><td><a href="#C%20interface">C interface</a>:</td><td>Use and inclusion of C libraries</td></tr>
<tr><td><a href="#C%20SECTION">C SECTION</a>:</td><td>transparent C source code inclusion</td></tr>
<tr><td><a href="#FORTRAN%20interface">FORTRAN interface</a>:</td><td>Use of FORTRAN subroutine calls</td></tr>
</table></nav>
</div><div class=page id="USE">
Node: (cpl)USE, Next: <a href="#INCLUDE">INCLUDE</a>, Prev: <a href="#Source%20file">Source file</a>, Up: <a href="#Source%20file">Source file</a>
<hr>

<h3>Separately compiled program segments</h3>

USE: separately compiled source files can be used with the statement

        USE &lt;filename&gt;

".cpl" is automatically appended if &lt;filename&gt; contains no dot. In addition,
the directory of the USEd file becomes the present working directory for other
references nested in it.

The USEd file is logically treated as if it were inserted in the program
sequence in place of the "USE" statement, i.e. just as if <a href="#INCLUDE">INCLUDE</a> were
in place. However, in reality the file is either compiled into a separate
object file or, if a more recent object file of the same name already exists,
not compiled at all. In the latter case the CPL compiler reads the outermost
block only from the USEd source file and skips the inner block contents
altogether, generating the same effect as a Modula-2 definition file or a C
header file.

In case actual headers must be generated in order to save space (or to
distribute a library without source code) it is possible to USE a source file
with empty subroutine bodies, since the compiler would not read the subroutine
bodies anyway, provided the object file is artificially given a more recent
date (for instance, through <a href="*manpages*.html#touch.)%20If%20this%20is%20not%20done,%20subroutines%20will%20be%20recompiled%20empty,%20with%20obviously%20unwanted%20results.%20%20In%20an%20interpreted%20program%20(*note%20icpl">(*manpages*)touch.) If this is not done,
subroutines will be recompiled empty, with obviously unwanted results.

In an interpreted program (*note icpl</a>) just as well, USE loads a separately
compiled module, whose subroutines can then be executed at compiled speed, and
executes its main body, if any, before passing control back to the console.
</div><div class=page id="INCLUDE">
Node: (cpl)INCLUDE, Next: <a href="#C%20interface">C interface</a>, Prev: <a href="#USE">USE</a>, Up: <a href="#Source%20file">Source file</a>
<hr>

<h3>File inclusion</h3>

Files included with

        INCLUDE filename[(name=value [,name=value])]

are treated as if they appeared in the place of the INCLUDE statement during
compilation, and are not separately compiled (as in <a href="#USE">USE</a>). Nonetheless,
the directory of the INCLUDEd file becomes the present working directory for
other references nested in it.

If the optional arguments are present, name becomes an alias for value within
the scope of the INCLUDEd file only.
</div><div class=page id="C%20interface">
Node: (cpl)C interface, Next: <a href="#C%20SECTION">C SECTION</a>, Prev: <a href="#INCLUDE">INCLUDE</a>, Up: <a href="#Source%20file">Source file</a>
<hr>

<h3>C interface</h3>

The directive

        #include "file"
or
        #include &lt;file&gt;
        
in addition to being copied into the generated C code has a special meaning.
"file" is expected to contain a C header or program, which is scanned for
declarations by the CPL compiler. The declarations and prototypes contained in
the C file thus become transparently available to the including CPL program.

An include directory path (similar to the "-I" C compiler directive) can be
specified with

        #includedir "path"

The name of the corresponding object file or other linking options can be
transmitted to the linker with

        #link "linking options"

A C code excerpt may also appear directly in the CPL source file if
encapsulated in a <a href="#C%20SECTION">C SECTION</a>.

The standard libc headers

        stdlib.h
        stdio.h
        fcntl.h
        math.h
        limits.h
        string.h
        setjmp.h
        errno.h
        signal.h

are pre-included in all CPL programs and need not (but may) be included again.
</div><div class=page id="C%20SECTION">
Node: (cpl)C SECTION, Next: <a href="#FORTRAN%20interface">FORTRAN interface</a>, Prev: <a href="#C%20interface">C interface</a>, Up: <a href="#Source%20file">Source file</a>
<hr>

<h3>C SECTION</h3>

C code excerpts can be inserted in a CPL program through the statement

        C SECTION
        &lt;C code&gt;
        END C SECTION
        
This has the same effect as recalling with #include a file that contains
&lt;C code&gt;. That is, the identifiers declared in the C SECTION become
transparently available to the CPL program.

As an alternative, C code may also be inserted between "&lt;*" and "*&gt;" as:

        &lt;* C code *&gt;
        
In this case, anything that appears between "&lt;*" and "*&gt;" is copied verbatim in
the generated C code without any intervention of the CPL compiler. It is up to
the programmer to ensure that the resulting code makes sense, so this
construction should only be used as a last resort.
</div><div class=page id="FORTRAN%20interface">
Node: (cpl)FORTRAN interface, Next: <a href="#MODULE">MODULE</a>, Prev: <a href="#C%20SECTION">C SECTION</a>, Up: <a href="#Source%20file">Source file</a>
<hr>

<h3>Use of FORTRAN subroutine calls</h3>

An interface to FORTRAN precompiled subroutines is provided by the statements

        FORTRANCALL &lt;subrname&gt; ( &lt;parameters&gt; )
and
        &lt;type&gt; FORTRANFUNCTION &lt;functionname&gt; ( &lt;parameters&gt; )
        
These have the following effects:
 &lt;subrname&gt; or &lt;functionname&gt; is copied verbatim into the generated C source,
 with an appended underscore; 
 all arguments are passed by reference, according to FORTRAN convention;
 any arrays are replaced by a reference to their first element.

The user must take care of the fact that FORTRAN has multidimensional array
indices in the reverse order with respect to both C and cpl. Arrays to be
passed as such arguments should be declared and used accordingly.

For (e.g. Lapack) library calls that require the number of elements used in
actual memory storage for the rows of a matrix as an argument, the
pseudofunction

        STRIDEOF( &lt;ARRAY&gt; )
        
provides the argument to be passed.

Note that argument type checking is suppressed during a FORTRANCALL (as the
necessary information is not available). Type checking can be restored,
however, by wrapping every FORTRANCALL in a suitable INLINE SUBROUTINE.

The name of the object file containing the FORTRAN compiled subroutines must be
transmitted to the linker with

        #link "linking options"

together with any other linking options required (e.g., -lg2c to provide the
FORTRAN run time library, if g77 was used as the FORTRAN compiler).
</div><div class=page id="MODULE">
Node: (cpl)MODULE, Next: <a href="#Functions">Functions</a>, Prev: <a href="#Source%20file">Source file</a>, Up: <a href="#Syntax">Syntax</a>
<hr>

<h2>Separately scoped program block</h2>

A block of code can be explicitly delimited as

        MODULE name
        &lt;block&gt;
        END name
or
        MODULE
        &lt;block&gt;
        END MODULE

This construction limits the visibility of variables declared inside the
MODULE, and is the basis for information hiding. It replaces, and should be
preferred to, called-once-only subroutines. An important difference is,
however, that variables declared in a MODULE are static and retain their value
across subroutine calls, even if they can only be accessed by subroutines
declared in the MODULE itself. Notice also that separate source files recalled
with either <a href="#USE">USE</a> or <a href="#INCLUDE">INCLUDE</a> are not separately scoped unless
they are enclosed in a MODULE. Control may be transferred to the end of a named
MODULE, just as to the end of a SUBROUTINE, by <a href="#EXIT">EXIT</a>.

In order to be exported outside, a function declared inside a module must also
be declared before the MODULE with the keyword <a href="#FOLLOWS">FOLLOWS</a>. Variables or
constants can be simply declared outside a MODULE and assigned a value inside
it as necessary.
</div><div class=page id="Functions">
Node: (cpl)Functions,  Next: <a href="#Declarations">Declarations</a>,  Prev: <a href="#Syntax">Syntax</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Functions and Subroutines</h1>

Functions (<a href="#FUNCTION">FUNCTION</a>) and subroutines (<a href="#SUBROUTINE">SUBROUTINE</a>) have a long
and a short declaration form. In long form, a subroutine declaration reads

        SUBROUTINE name( &lt;parameter declarations&gt; )
        &lt;block&gt;
        END name
        
Correspondingly a function, i.e. a subroutine that returns a value and may
appear inside an expression, is declared as

        &lt;type&gt; FUNCTION name( &lt;parameter declarations&gt; )
        &lt;block&gt;
        END name
        
In short form, a function whose body is composed of a single expression
may also be declared as

        &lt;type&gt; FUNCTION name( &lt;parameter declarations&gt; ) = &lt;expression&gt;

A short syntax is also available for subroutines

        SUBROUTINE name( &lt;parameter declarations&gt; ) = &lt;single-line block&gt;
        
where &lt;single-line block&gt; is a sequence of statements separated by semicolons
and terminating at the first newline.

CPL has Custom Parameter lists, meaning that not just commas but any
non-ambiguous single character or character sequence may be used as parameter
separator. In parameter declarations non-alphanumeric separators can be
specified verbatim, whereas separators that could be mistaken for identifiers
are to be enclosed in (either single or double) quotes. In subroutine and
function calls the quotes are omitted, and the compiler enforces conforming
separators. Whereas commas will still be the commonest choice for short
parameter lists, the adoption of remindful separators can make long parameter
lists both more understandable and more thoroughly checked by the compiler.

Formal parameter declarations otherwise follow the same syntax as normal
variable declarations, and are distinguished both by their position within the
parenthesis following the subroutine or function name and by separator
matching. Round, square or curly brackets can be used, just as everywhere else
(<a href="#Parentheses">Parentheses</a>). However an important difference exists: whereas general
variables are by default <a href="#VARIABLE">VARIABLE</a>, i.e. can be assigned a value
multiple times, and must be explicitly declared <a href="#CONSTANT">CONSTANT</a> to become
inalterable, formal parameters are by default CONSTANT and only become VARIABLE
if explicitly declared so. Parameters can be <a href="#OPTIONAL">OPTIONAL</a>, and be specified
by name rather than by position.

A subroutine returns at the END of the subroutine block or at the <a href="#EXIT">EXIT</a> 
statement. Within functions a variable named RESULT is implicitly declared with
the type of the function's result, and can be used just as any other local
variable of that type within the body of the function; the function returns the
value of the variable <a href="#RESULT">RESULT</a> at the time of exit.

The declared subroutine is visible from the point of its declaration to the
end of the enclosing block, just as all other declarations. This includes the
subroutine body itself, and recursive calls are thus automatically allowed.

Function overloading is an inherent feature of CPL. Since type checking is
enforced on function arguments, functions and subroutines of the same name but
different (not <a href="#OPTIONAL">OPTIONAL</a>) arguments can be distinguished from each
other, and are transparently handled. For other object-oriented features
see also <a href="#DYNAMIC">DYNAMIC</a>.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#Nested%20functions">Nested functions</a>:</td><td></td></tr>
<tr><td><a href="#SUBROUTINE">SUBROUTINE</a>:</td><td>Subroutine declaration</td></tr>
<tr><td><a href="#FUNCTION">FUNCTION</a>:</td><td>Function declaration</td></tr>
<tr><td><a href="#INLINE">INLINE</a>:</td><td>Subroutines and functions as macros</td></tr>
<tr><td><a href="#FOLLOWS">FOLLOWS</a>:</td><td>Function prototypes</td></tr>
<tr><td><a href="#OPTIONAL">OPTIONAL</a>:</td><td>optional function parameters recognized by name</td></tr>
<tr><td><a href="#Subroutine%20type">Subroutine type</a>:</td><td>variable call to a subroutine or function</td></tr>
<tr><td><a href="#Builtin">Builtin</a>:</td><td>built-in function list</td></tr>
</table></nav>
</div><div class=page id="Nested%20functions">
Node: (cpl)Nested functions, Next: <a href="#SUBROUTINE">SUBROUTINE</a>, Prev: <a href="#Functions">Functions</a>, Up: <a href="#Functions">Functions</a>
<hr>

<h2>Nested functions</h2>

Functions and subroutines exist on a par with variable <a href="#Declarations">Declarations</a> and
can appear anywhere in a block, another function included. Nested functions are
therefore an integral part of CPL. Like all other block contexts, they have
access to variables (and functions) declared before them, in the same or in
an enclosing block. The present implementation of nested functions translates
to nested functions in the generated C code, and is therefore only compatible
with C compilers that handle nested functions as a nonstandard feature (gcc is
one of them).
</div><div class=page id="SUBROUTINE">
Node: (cpl)SUBROUTINE, Next: <a href="#FUNCTION">FUNCTION</a>, Prev: <a href="#Nested%20functions">Nested functions</a>, Up: <a href="#Functions">Functions</a>
<hr>

<h2>Subroutine declarations</h2>

In long form, a subroutine declaration reads

        SUBROUTINE name( &lt;parameter declarations&gt; )
        &lt;block&gt;
        END name

In short form:

        SUBROUTINE name( &lt;parameter declarations&gt; ) = &lt;single-line block&gt;
        
where &lt;single-line block&gt; is a sequence of statements separated by semicolons
and terminated by the first newline.

The keyword SUBROUTINE is also used to declare variables of <a href="#Subroutine%20type">Subroutine
type</a>.
</div><div class=page id="FUNCTION">
Node: (cpl)FUNCTION, Next: <a href="#INLINE">INLINE</a>, Prev: <a href="#SUBROUTINE">SUBROUTINE</a>, Up: <a href="#Functions">Functions</a>
<hr>

<h2>Function declarations</h2>

In long form, a function declaration reads

        &lt;type&gt; FUNCTION name( &lt;parameter declarations&gt; )
        &lt;block&gt;
        END name
        
In short form, a function whose result can be written as a single expression 
may also be declared as

        &lt;type&gt; FUNCTION name( &lt;parameter declarations&gt; ) = &lt;expression&gt;

Within a function's body, a variable named

        RESULT

is implicitly declared with the type of the function's result, and can be used
just as any other local variable of that type within the body of the function;
the function returns the value of the variable <a href="#RESULT">RESULT</a> at the time of
exit. All primitive and compound types are allowed for the result of a function.
The statement

        RETURN &lt;value&gt;
        
is a shorthand for

        RESULT=&lt;value&gt;; EXIT &lt;function&gt;. 

The keyword FUNCTION is also used to declare variables of <a href="#Subroutine%20type">Subroutine
type</a>. The statement RETURN is also used in <a href="#interactive%20session">interactive session</a>.
</div><div class=page id="INLINE">
Node: (cpl)INLINE,  Next: <a href="#FOLLOWS">FOLLOWS</a>,  Prev: <a href="#FUNCTION">FUNCTION</a>,  Up: <a href="#Functions">Functions</a>
<hr>

<h2>Inline functions and subroutines</h2>

The keyword INLINE prefixed to a <a href="#SUBROUTINE">SUBROUTINE</a> or <a href="#FUNCTION">FUNCTION</a>
declaration (either in long or short form) generates a compile-time macro that
is inserted in place of each call to the subroutine.

<a href="#EXIT">EXIT</a> cannot presently be used in INLINE functions.

See also <a href="#INLINE%20LOOP">INLINE LOOP</a>.
</div><div class=page id="FOLLOWS">
Node: (cpl)FOLLOWS,  Next: <a href="#OPTIONAL">OPTIONAL</a>,  Prev: <a href="#INLINE">INLINE</a>,  Up: <a href="#Functions">Functions</a>
<hr>

<h2>Function prototypes</h2>

In case the prototype of a subroutine must be declared in advance, the
construction

        SUBROUTINE name( &lt;parameter declarations&gt; ) FOLLOWS
        
(or its equivalent for functions) can be used to make the subroutine callable
before its complete declaration appears. This prototype declaration is only
needed for mutually referencing subroutines (as in Pascal or C) or for
subroutines whose body is hidden in a subsequent <a href="#MODULE">MODULE</a>.

A prototype may also be defined for a <a href="#CONSTANT">CONSTANT</a>.
</div><div class=page id="OPTIONAL">
Node: (cpl)OPTIONAL,  Next: <a href="#RESULT">RESULT</a>,  Prev: <a href="#FOLLOWS">FOLLOWS</a>,  Up: <a href="#Functions">Functions</a>
<hr>

<h2>Optional parameters</h2>

The parameter list of a function or subroutine can include optional items.
In the function declaration, optional parameters must appear after all ordinary
positional parameters (if there are any), separated by the keyword OPTIONAL.
Each optional parameter must be assigned a default value in its declaration.
Example:

        SUBROUTINE test(INTEGER x; OPTIONAL INTEGER y=0,z=3; REAL w=3.14)

In the body of the function optional parameters obey the same rules as local
constants or variables (if qualified <a href="#VARIABLE">VARIABLE</a>), just like ordinary
parameters; on entry they acquire the value of the corresponding actual parame-
ter if specified in the calling statement, or their default value otherwise.

In the calling statement, optional parameters follow all standard positional
parameters and can appear in any order (or not appear at all); they are
identified by name rather than by position. In the above example:

        test(3,w=1E2,y=1)

Optional parameters cannot be used to disambiguate overloaded function names.
</div><div class=page id="RESULT">
Node: (cpl)RESULT, Next: <a href="#Declarations">Declarations</a>, Prev: <a href="#OPTIONAL">OPTIONAL</a>, Up: <a href="#Functions">Functions</a>
<hr>

Formal name of the result of a <a href="#FUNCTION">FUNCTION</a> inside of the function's body.
RESULT is implicitly declared as a variable of the type indicated in the
FUNCTION's declaration and may be used and assigned like any other variable. On
exit it becomes the function's value returned to the calling program.
</div><div class=page id="Declarations">
Node: (cpl)Declarations, Next: <a href="#Statements">Statements</a>, Prev: <a href="#Functions">Functions</a>, Up: <a href="#Top">Top</a>
<hr>

<h1>Variables, types and constants</h1>

Variables, types and constants are denoted by identifiers introduced through
the relevant declarations as follows. Identifiers cannot be duplicated as long
as a previous declaration is in effect (in either the same or an enclosing
block). An identifier which was not previously declared in the same or an
enclosing block and does not coincide with a CPL keyword (see <a href="#Keyword%20index">Keyword
index</a>) is denoted as a newid below.

A general declaration has the form:

    [&lt;constorvar&gt;] &lt;type declarator&gt; &lt;vardeclaration&gt; [, &lt;vardeclaration&gt;]

where &lt;vardeclaration&gt; denotes

    newid[&lt;postfix modifier&gt;][= &lt;value&gt;]

and &lt;constorvar&gt; may be either <a href="#CONSTANT">CONSTANT</a> or <a href="#VARIABLE">VARIABLE</a> or none.

CPL is a type-checking language and requires that every VARIABLE be declared
before it is used. It can be initialized at the same time by the optional
= &lt;value&gt; field. However, the declaration of CONSTANTs and TYPEs may be
implicit:

  newid = &lt;value&gt;  declares a <a href="#CONSTANT">CONSTANT</a>, whose value cannot be modified
                 later in the program and whose type is the type of the r.h.s.
  newid = &lt;compound type&gt;  declares a <a href="#TYPE">TYPE</a> identifier to denote the
                 compound type on the r.h.s.
  A newid used as the running index of a <a href="#FOR">FOR</a> loop is implicitly
                 declared CONSTANT in the scope of the loop.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#CONSTANT">CONSTANT</a>:</td><td>constant identifier</td></tr>
<tr><td><a href="#VARIABLE">VARIABLE</a>:</td><td>variable identifier</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
Primitive types are:

<nav><table>
<tr><td><a href="#BOOLEAN">BOOLEAN</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#CHAR">CHAR</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#INTEGER">INTEGER</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#REAL">REAL</a>:</td><td>primitive type declarator</td></tr>
<tr><td><a href="#SINGLE">SINGLE</a>:</td><td>primitive type declarator</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
Compound types may be equivalently specified through a compound type expression
or type identifier used as the type declarator (common to all variables in the
declaration list) or through a &lt;postfix modifier&gt; attached to each single
variable to which it is meant to apply.

<nav><table>
<tr><td><a href="#TYPE">TYPE</a>:</td><td>declaration of a new type identifier</td></tr>
<tr><td><a href="#STRUCTURE">STRUCTURE</a>:</td><td>compound variables</td></tr>
<tr><td><a href="#ARRAY">ARRAY</a>:</td><td>subscripted arrays</td></tr>
<tr><td><a href="#STRING">STRING</a>:</td><td>strings of characters</td></tr>
<tr><td><a href="#STRUCTURED">STRUCTURED</a>:</td><td>ARRAY     may appear as both a structure and an array</td></tr>
<tr><td><a href="#POINTER">POINTER</a>:</td><td>pointer to a memory address</td></tr>
<tr><td><a href="#INTO">INTO</a>:</td><td>Pointer arithmetics</td></tr>
<tr><td><a href="#STORED">STORED</a>:</td><td>random-access files as disk-resident variables</td></tr>
<tr><td><a href="#DYNAMIC">DYNAMIC</a>:</td><td>object-oriented features</td></tr>
<tr><td><a href="#Postfix">Postfix</a>:</td><td>shorthand notation for POINTERs and ARRAYs</td></tr>
<tr><td><a href="#Subroutine%20type">Subroutine type</a>:</td><td>variable call to a subroutine or function</td></tr>
<tr><td><a href="#Type%20identity">Type identity</a>:</td><td>when are two variables of the same type?</td></tr>
</table></nav>
</div><div class=page id="CONSTANT">
Node: (cpl)CONSTANT, Next: <a href="#VARIABLE">VARIABLE</a>, Prev: <a href="#Declarations">Declarations</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>CONSTANT</h2>

The word CONSTANT in <a href="#Declarations">Declarations</a> specifies that the declared item
cannot be modified. Thus a CONSTANT is not the same thing as a "compile-time
constant", that is an expression whose value can be known at compile time, but
more generally a value which cannot appear on the left side of an assignment or
have its address assigned to a POINTER.

The value of the CONSTANT is usually specified in the declaration itself but
occasionally later. When this happens the constant declaration takes the role
of a constant prototype, and may be optionally followed by the keyword <a href="#FOLLOWS">
FOLLOWS</a>. (For instance, a constant may be declared outside a <a href="#MODULE">MODULE</a>,
but its value only be known inside the module itself; or the value may be <a href="#READ">
READ</a> as input.) If the constant is not initialized in the declaration itself,
it is understood that it will be assigned once only in the course of its block.

In alternative, a statement of the form

        newid = value
        
implicitly declares a CONSTANT whose type is the type of the r.h.s. and assigns
its value (see, however, <a href="#Concealed%20Pointer%20Lookup">CONSTANT:Concealed Pointer Lookup</a>).

If the r.h.s. of a CONSTANT declaration is known at compile time (what is
denoted as a compile-time constant), the new identifier becomes just an alias
for it and no storage is assigned. This also applies to <a href="#STRING">STRING</a>s. An
alias for any expression, even one which does not represent a compile-time
constant, can always be defined through the statement

        newid == expression

Subroutine formal parameters are by default CONSTANT, with the actual parameter
as their value, and must be explicitly declared <a href="#VARIABLE">VARIABLE</a> if they are to
be reassigned within the subroutine's body.
</div><div class=page id="VARIABLE">
Node: (cpl)VARIABLE, Next: <a href="#BOOLEAN">BOOLEAN</a>, Prev: <a href="#CONSTANT">CONSTANT</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>VARIABLE</h2>

The word VARIABLE in <a href="#Declarations">Declarations</a> specifies that the declared item is a
regular variable and can be modified. In fact, this is the default and the word
VARIABLE is optional in ordinary declarations.

However, subroutine formal parameters are by default <a href="#CONSTANT">CONSTANT</a>, with the
actual parameters as values, and must be explicitly declared VARIABLE if they
are to be reassigned within the subroutine's body.

Notice that the value assigned to a VARIABLE parameter is invisible after the
subroutine returns. In order to change the value of variables which exist
outside the subroutine, the corresponding formal parameter must be declared
<a href="#POINTER">POINTER</a>. Indeed VARIABLE behaviour of a formal parameter is seldom
needed, and making CONSTANT the default improves error catching.

When a VARIABLE identifier is used in an expression, it initially stands for
the variable's address in memory, and thus can be used wherever a POINTER is
expected; the same identifier gets automatically converted to the variable's
value where needed through <a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>.
</div><div class=page id="BOOLEAN">
Node: (cpl)BOOLEAN, Next: <a href="#CHAR">CHAR</a>, Prev: <a href="#VARIABLE">VARIABLE</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>BOOLEAN</h2>

Primitive type declarator for boolean logical variables translated into C type
"int". (<a href="#Declarations">Declarations</a>)

BOOLEAN values are denoted as YES or TRUE and NO or FALSE, and written as "Y"
and "N". On reading any complete word starting with "T", "Y", "t" or "y" is
read as YES, any word starting with "F", "N", "f", "n" as NO.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#BOOLEAN%20ops">BOOLEAN ops</a>:</td><td>AND  OR  NOT</td></tr>
<tr><td><a href="#Comparison">Comparison</a>:</td><td>&gt;  &gt;=  &lt;  &lt;=  =  #  IS</td></tr>
<tr><td><a href="#Builtin">BOOLEAN:Builtin</a>:</td><td>built-in functions</td></tr>
</table></nav>
</div><div class=page id="CHAR">
Node: (cpl)CHAR,  Next: <a href="#INTEGER">INTEGER</a>,  Prev: <a href="#BOOLEAN">BOOLEAN</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>CHAR</h2>

Primitive type declarator for character variables translated into C type
"char". (<a href="#Declarations">Declarations</a>)

Where needed, a single-character <a href="#STRING">STRING</a> literal is implicitly converted
to a CHAR constant, which is in turn implicitly converted to an INTEGER ASCII
code. INTEGER to CHAR conversion must be explicit (<a href="#Builtin">CHAR:Builtin</a>).
</div><div class=page id="INTEGER">
Node: (cpl)INTEGER,  Next: <a href="#REAL">REAL</a>,  Prev: <a href="#CHAR">CHAR</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>INTEGER</h2>

Primitive type declarator for integer variables, translated into C type "int".

Can be implicitly converted to REAL. REAL to INTEGER conversion must be
explicit (<a href="#Builtin">INTEGER:Builtin</a>).

See also <a href="#INTEGER%20operator">INTEGER operator</a>.
</div><div class=page id="REAL">
Node: (cpl)REAL,  Next: <a href="#SINGLE">SINGLE</a>,  Prev: <a href="#INTEGER">INTEGER</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>REAL</h2>

Primitive type declarator for real variables, translated into C type "double".

See also <a href="#REAL%20operator">REAL operator</a>, <a href="#Builtin">REAL:Builtin</a>.
</div><div class=page id="SINGLE">
Node: (cpl)SINGLE,  Next: <a href="#TYPE">TYPE</a>,  Prev: <a href="#REAL">REAL</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>SINGLE</h2>

Primitive type declarator for single-precision real variables, translated into
C type "float".

Can be implicitly converted to REAL. REAL to SINGLE conversion must be explicit
(<a href="#Builtin">SINGLE:Builtin</a>).
</div><div class=page id="TYPE">
Node: (cpl)TYPE, Next: <a href="#STRUCTURE">STRUCTURE</a>, Prev: <a href="#REAL">REAL</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Declaration of new type identifiers</h2>

A new type identifier can be declared as either

        TYPE newid = &lt;compound type&gt;
or just
        newid = &lt;compound type&gt;
        
The new identifier can be used in subsequent declarations in the place of the
r.h.s.

The TYPE of an already declared variable or expression can always be recovered
from the pseudo-function

        TYPEOF(&lt;variable&gt;)

which can appear wherever a type name can. (E.g., it can be assigned to a type
identifier or directly used to declare further variables or in the construction
of a compound type.) When applied to a <a href="#POINTER">POINTER</a> or <a href="#STORED">STORED</a> type,
this function returns the underlying base type.

In order to test whether a variable is of a given type the <a href="#IS">IS</a>
comparison operator is available. See also <a href="#Type%20identity">Type identity</a>.

The memory size in bytes of a type or variable (useful when using the <a href="#C%20interface">C
interface</a> or to estimate the memory requirements of the program) can be
obtained from the pseudo-function

        SIZEOF(&lt;typeorvariable&gt;)
</div><div class=page id="STRUCTURE">
Node: (cpl)STRUCTURE, Next: <a href="#ARRAY">ARRAY</a>, Prev: <a href="#TYPE">TYPE</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>STRUCTUREs</h2>

The type declarator for structures is

        STRUCTURE(&lt;field declarations&gt;)

Field declarations follow exactly the same syntax as general variable
declarations. For instance, to declare a structure containing one integer field
named i and two real fields named x and y, one would write:

        STRUCTURE(INTEGER i; REAL x,y)

Structure elements are selected by either the traditional dot notation

        structure.field
        
or the selector-function notation

        field(structure)
        
Conversely, any function of a single argument can be called either as

        function(argument)
or as
        argument.function
        
(familiar to those who are accustomed to object-oriented languages).

A structure declaration may also contain one or more anonymous fields. If a
type declarator appears alone, without any following variable declaration, an
anonymous field is declared to which the given structure can be implicitly
converted. For instance, after the declaration:

        TYPE t1=STRUCTURE(REAL a,b)
        STRUCTURE(t1; INTEGER n) var
        
var includes a field of type t1 of which var.a denotes the "a" field.

Anonymous structure fields are the CPL way of defining objects that inherit the
structure of other more general objects and add their own specific fields. When
these objects are accessed as arguments to functions or subroutines, the
appropriate function among those with the same name and different arguments is
automatically selected. See also <a href="#Functions">overloading:Functions</a>, <a href="#DYNAMIC">DYNAMIC</a>.
</div><div class=page id="ARRAY">
Node: (cpl)ARRAY, Next: <a href="#STRUCTURED">STRUCTURED</a>, Prev: <a href="#STRUCTURE">STRUCTURE</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>ARRAYs</h2>

The prefix type declarator for arrays is

        ARRAY(dimension[,dimension]) OF &lt;type&gt;
        
The postfix declarator is just (dimension[,dimension]). Each dimension is
specified either as &lt;lower bound&gt;..&lt;upper bound&gt; or as &lt;upper bound&gt; only, in
which case the lower bound is taken to be zero. Specifying multiple dimensions,
like in ARRAY(dimension1,dimension2) OF, is a shorthand for

        ARRAY(dimension1) OF ARRAY(dimension2) OF

Therefore the order in which the elements of the array are stored in memory is
similar to C and Pascal and different from FORTRAN.

Variable dimensions are allowed wherever constant dimensions are; the compiler
automatically decides for static or dynamic allocation of memory space as
needed. Arrays can contain elements of any primitive or compound type and can
in turn appear as fields in structures or be pointed at by pointers.

When an ARRAY is assigned in a single = statement to another of the same base
type and number of elements, its lower bound is implicitly realigned. A similar
realignment takes place for function arguments. Assigning to a different base
type triggers an error. Mismatch in the number of elements is flagged by
<a href="#rtchecks">rtchecks</a>.

The special dimension * can only appear in the declaration of an ARRAY formal
parameter or of a POINTER TO ARRAY, and declares a special type of pointer that
remembers the current dimensions of the array together with its address. A
formal parameter or pointer of this type can be dynamically assigned arrays
of different length and still provide runtime range checking and <a href="#FOR%20ALL">FOR
ALL</a> looping when requested. The actual upper and lower bounds of an array
index can always be recovered through the functions <a href="#HI">HI</a> and <a href="#LO">LO</a>,
and the total number of elements through the function <a href="#LENGTH">LENGTH</a>. In the
case of multidimensional arrays, these functions apply to the first index only;
<a href="#subarray">subarray</a> selection can be used in order to extract the bounds of other
indices. Alternatively, LO1, LO2, LO3 and HI1, HI2, HI3 can be used to refer to
the first three indices.

ARRAY elements are accessed through INTEGER indices in brackets as usual, e.g.:

        REAL arr(1..8,2..9)
        WRITE arr(4,5)
        
All three kinds of bracket are allowed (<a href="#Parentheses">Parentheses</a>). It should be
noted that the above declaration is a shorthand for

        ARRAY(1..8) OF ARRAY(2..9) OF REAL arr
        
Therefore, a notation such as arr(4) is allowed, and has type ARRAY(2..9) OF
REAL. This is a particular case of a <a href="#subarray">subarray</a>. By the same token, the
second line might also have been written as

        WRITE arr(4)(5)

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
The following special operations are defined on ARRAYs:

<nav><table>
<tr><td><a href="#HI">HI</a>:</td><td>upper bound of an array index</td></tr>
<tr><td><a href="#LO">LO</a>:</td><td>lower bound of an array index</td></tr>
<tr><td><a href="#LENGTH">LENGTH</a>:</td><td>number of elements of an array</td></tr>
<tr><td><a href="#subarray">subarray</a>:</td><td>subarray selection</td></tr>
<tr><td><a href="#compound%20index">compound index</a>:</td><td>sequential access to a multidimensional array</td></tr>
<tr><td><a href="#ARRAY%20operations">ARRAY operations</a>:</td><td>linear space</td></tr>
<tr><td><a href="#Einstein%20convention">Einstein convention</a>:</td><td>implicit index iteration</td></tr>
<tr><td><a href="#INTO">Pointer arithmetics:INTO</a>:</td><td></td></tr>
</table></nav>
</div><div class=page id="HI">
Node: (cpl)HI,  Next: <a href="#LO">LO</a>,  Prev: <a href="#ARRAY">ARRAY</a>,  Up: <a href="#ARRAY">ARRAY</a>
<hr>

HI:                        upper bound of an array index

The function HI applied to an ARRAY returns the upper bound of its first index.
HI1 is a synonym for HI; HI2 and HI3 return the upper bound of the second and
third index respectively. Further indices can be accessed by <a href="#subarray">subarray</a>
selection.

The argument of HI is implicit (i.e., HI may be written without any argument as
if <a href="#WITH">WITH</a> were in action) when HI is used inside the index itself as in
arr(HI-3) or in the specification of a <a href="#FOR">FOR</a> loop.
</div><div class=page id="LO">
Node: (cpl)LO,  Next: <a href="#LENGTH">LENGTH</a>,  Prev: <a href="#HI">HI</a>,  Up: <a href="#ARRAY">ARRAY</a>
<hr>

LO:                        lower bound of an array index

The function LO applied to an ARRAY returns the lower bound of its first index.
LO1 is a synonym for LO; LO2 and LO3 return the lower bound of the second and
third index respectively. Further indices can be accessed by <a href="#subarray">subarray</a>
selection.

The argument of LO is implicit (i.e., LO may be written without any argument as
if <a href="#WITH">WITH</a> were in action) when LO is used inside the index itself as in
arr(LO+2) or in the specification of a <a href="#FOR">FOR</a> loop.
</div><div class=page id="LENGTH">
Node: (cpl)LENGTH,  Prev: <a href="#LO">LO</a>,  Up: <a href="#ARRAY">ARRAY</a>
<hr>

LENGTH:                        number of elements of an array

The function LENGTH applied to an ARRAY returns its number of elements. LENGTH
is equivalent to HI-LO+1. In a multidimensional ARRAY, the number of values of
the first index only is returned.
</div><div class=page id="STRING">
Node: (cpl)STRING, Next: <a href="#STRUCTURED">STRUCTURED</a>, Prev: <a href="#ARRAY">ARRAY</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>STRINGs</h2>

Type declaration STRING is a synonim for ARRAY(*) OF <a href="#CHAR">CHAR</a>, and can be
used wherever the last can. In particular, a STRING can be subscripted or <a href="#subarray">
subarray</a> extracted, and its bounds and length are available through functions
<a href="#LO">LO</a>, <a href="#HI">HI</a>, and <a href="#LENGTH">LENGTH</a>. STRING valued constants (which are
always indexed starting from 0) can be generated either at compile time, as
quoted strings of characters, or dynamically through <a href="#String">String</a>
concatenation, and can either be given a name through <a href="#CONSTANT">implicit:
CONSTANT</a>. declaration or passed as actual parameters to function calls and
further string concatenations.

Quoted strings of characters, also known as literals, are delimited by either
double (") or single (') quotes, in matching pairs. A single quote may appear
inside a literal delimited by double quotes and vice versa. In addition, C
escape sequences are literals, but contrary to C must be unquoted.  The empty
string "" is also a valid (zero-character-long) STRING value. Finally, in
bash-like syntax, multi-line literals may be introduced by &lt;&lt; DELIMITER and
ended by DELIMITER alone on a new line, where DELIMITER can be any word that is
not to be part of the literal itself.

Where appropriate, a single-character literal is implicitly converted to a CHAR
constant, which is in turn implicitly converted to an INTEGER ASCII code.
Strings may also be concatenated among themselves and with variables, see <a href="#String">
conversion:String</a>.

Standard C functions returning a char* (<a href="/usr/share/info/libc.html#%20String%20and%20Array%20Utilities">(/usr/share/info/libc) String and
Array Utilities</a>) are also interpreted as generating a STRING value. Just
as for all <a href="#C%20Interface">C Interface</a> calls, it is the programmer's responsibility to
ensure that such C library functions are used consistently and to free any
possible malloc-ated space where appropriate.

As an experimental feature, and an exception to the general rule for ARRAY(*),
STRING VARIABLEs may also be declared and assigned a value.

<nav><table>
<tr><th>Menu:</th><th>Predefined strings are:</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#COMMANDLINE">COMMANDLINE</a>:</td><td>command line parameter access</td></tr>
<tr><td><a href="#TRAP">ERRORMESSAGE:TRAP</a>:</td><td>error message string</td></tr>
</table></nav>
</div><div class=page id="STRUCTURED">
Node: (cpl)STRUCTURED, Next: <a href="#POINTER">POINTER</a>, Prev: <a href="#STRING">STRING</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>STRUCTURED ARRAY</h2>

A structure (<a href="#STRUCTURE">STRUCTURE</a>) of like elements that may also be accessed as a
linear array (<a href="#ARRAY">ARRAY</a>) of such. Its type declarator is

        STRUCTURED ARRAY(&lt;field declarations&gt;) OF &lt;type&gt;

where &lt;field declarations&gt;, separated by commas, are either single newids or
newids followed by (possibly multiple) array dimensions. For example,

        STRUCTURED ARRAY(a,b,c(1..4,1..2)) OF REAL stra

defines a STRUCTURE named stra with fields a, b of type REAL and c of type
ARRAY(1..4,1..2) OF REAL. At the same time, stra may also be accessed as an
ARRAY(0..9) OF REAL, with automatically determined bounds. This is particularly
useful when the new type has to be subjected to <a href="#ARRAY%20operations">ARRAY operations</a>. For
instance, one can define a "Vector" type with fields x,y,z and then perform
vector operations on variables of this type.
</div><div class=page id="POINTER">
Node: (cpl)POINTER,  Next: <a href="#INTO">INTO</a>,  Prev: <a href="#ARRAY">ARRAY</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>POINTERs</h2>

The type declarator for pointers is POINTER TO (prefix) or ^ (postfix)
(<a href="#Postfix">Postfix</a>). For example

        POINTER TO INTEGER a,b; INTEGER c
and
        INTEGER a^,b^,c

are equivalent declarations. The notation for pointer dereferencing is
described in <a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>.

A null pointer is denoted by the predefined constant

        NULL &lt;type&gt;
        
which translates to the C constant NULL (generally the address 0) with type
&lt;type&gt; if this is a POINTER type, or POINTER TO &lt;type&gt; otherwise.

<h3>Uncommitted POINTERs</h3>

A pointer can also be declared with reference to a (yet) uncommitted type name,
by the notation

        POINTER TO &lt;newid&gt;

It is implied that &lt;newid&gt; will later denote a type identifier. Variables,
constants and structure fields of uncommitted pointer type can be declared,
assigned and compared to each other like all POINTERs but not dereferenced.
They become POINTERs in full rights as soon as a declaration for type &lt;newid&gt;
is encountered.

Uncommitted pointers acquire a special meaning if used as formal parameters or
function results (in which case no explicit declaration of type &lt;newid&gt; shall
follow): a formal parameter of uncommitted pointer type can receive an actual
parameter of any POINTER type (except POINTER TO ARRAY(*), which needs special
treatment) as argument, thus allowing the coding of subroutines for the
manipulation of generic pointers. Type checking will still be enforced based
on the equality of type name. Of course, uncommitted pointers of this kind can
never be dereferenced within the body of the subroutine itself.

See also <a href="#NEW">Memory allocation:NEW</a>, <a href="#DYNAMIC">Object-oriented features:DYNAMIC</a>.
</div><div class=page id="INTO">
Node: (cpl)INTO, Next: <a href="#DYNAMIC">DYNAMIC</a>, Prev: <a href="#POINTER">POINTER</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Pointer arithmetics</h2>

Pointer arithmetics is the most powerful feature C has in common with assembly
language. It is, however, also one of its weakest points as far as type
checking is concerned. For these reasons CPL only allows restricted forms of
pointer arithmetics. One of these is <a href="#subarray">subarray</a> extraction. The other is
the type declarator

        POINTER INTO &lt;array&gt;

which defines a pointer that can be decremented or incremented provided it
stays within the bounds of ARRAY &lt;array&gt;. Arithmetics on such a pointer is
allowed just as if it were an ordinary INTEGER; dereferencing is not implicit,
as for ordinary POINTERS would be, but is obtained by using it as an index into
its base array. For instance:

        REAL R(10)
        R(5)=0.5
        POINTER INTO R ip
        ip=3
        ip=ip+2
        WRITE R(ip)

In other words, code is written just as if an INTEGER index were used, but the
program is compiled to use a pointer instead. This can sometimes improve
performance, especially in short loops that perform few repetitive operations.
</div><div class=page id="DYNAMIC">
Node: (cpl)DYNAMIC, Next: <a href="#IS">IS</a>, Prev: <a href="#INTO">INTO</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Object-oriented features</h2>

CPL is not an object-oriented language in the sense that functions are
supposed to be declared within object class declarations, and intentionally
so. Object-like behaviour is achieved through overloaded function names (<a href="#Functions">
Function overloading:Functions</a>) and implicit type conversion (<a href="#STRUCTURE">
anonymous:STRUCTURE</a>).

In addition, situations where the type of an object is not fixed at compile
time are catered for by "dynamic pointers", pointers that can reference and
provide type checking for objects whose type will only be known at run time.
These are declared by the type declarator

        DYNAMIC POINTER
        
A function call in which such a pointer appears is transparently switched at
run time to the function defined for the appropriate type, or an error is
signalled if no such function exists.

Pointers to variables of any type except ARRAY(*) and STORED can be assigned
to a DYNAMIC POINTER. If the scope of assignment is to be restricted, the
declaration becomes

        DYNAMIC POINTER TO &lt;type declarator&gt;

In this case only types which can be implicitly converted to &lt;type declarator&gt;
are acceptable for the variable pointed to.

The actual type a dynamic pointer points to can be tested by the <a href="#IS">IS</a>
operator.
</div><div class=page id="IS">
Node: (cpl)IS,  Next: <a href="#Postfix">Postfix</a>,  Prev: <a href="#DYNAMIC">DYNAMIC</a>,  Up: <a href="#DYNAMIC">DYNAMIC</a>
<hr>

<h3>Type comparison</h3>

The actual type of the variable pointed to by a dynamic pointer (or, for that
matter, of any variable) can be tested by the BOOLEAN expression

        &lt;pointer&gt; IS &lt;type&gt;

For instance, in

        DYNAMIC POINTER dyn
        ............
        IF dyn IS INTEGER THEN
        ............
        END IF

the IF block is executed only if the dynamic pointer dyn points at run time to
a variable of INTEGER type. In addition, the IS test has the side effect of
casting a dynamic pointer to an ordinary pointer of the tested type when the
test succeeds, thus allowing its use as a regular variable. That is, in the
above example dyn is implicitly converted to a POINTER TO INTEGER for the scope
of the IF block. A restricted dynamic pointer may always be implicitly
converted to its base type, as compatibility is enforced at compile time.
</div><div class=page id="Postfix">
Node: (cpl)Postfix, Next: <a href="#Subroutine%20type">Subroutine type</a>, Prev: <a href="#DYNAMIC">DYNAMIC</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Postfix type modifiers</h2>

A postfix ^ denotes either pointer dereferencing (<a href="#Concealed%20Pointer%20Lookup">^:Concealed Pointer
Lookup</a>) or a short form of the POINTER declaration. For instance

                        INTEGER a^,b^
is a shorthand for
                        POINTER TO INTEGER a,b

A postfix form of the ARRAY declaration

        ARRAY(1..10) OF REAL a,b,c
is
        REAL a(1..10),b(1..10),c(1..10)

When both a postfix modifier and a prefix type declarator are simultaneously
present in a declaration, they represent the compound type that is obtained by
prepending the postfix modifier to the type declarator. For example

        STRUCTURE(INTEGER x,y) A^(10)
        
is equivalent to

        POINTER TO ARRAY(10) OF STRUCTURE(INTEGER x,y) A
</div><div class=page id="Subroutine%20type">
Node: (cpl)Subroutine type, Next: <a href="#Type%20identity">Type identity</a>, Prev: <a href="#Postfix">Postfix</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Variable call to a subroutine or function</h2>

A subroutine variable may be specified through the type declarator

        SUBROUTINE( &lt;parameter declarations&gt; )

A function variable may be specified through the type declarator

        FUNCTION( &lt;parameter declarations&gt; )-&gt;&lt;type&gt;
or else
        &lt;type&gt; FUNCTION( &lt;parameter declarations&gt; )

the first form being mandatory when the result &lt;type&gt; is a pointer type and
thus ambiguity can arise.

These type declarators can be used, just like all other type declarators, to
declare variables and formal parameters, or as part of new compound types. In
addition to being assigned or compared to each other, subroutine variables can
be assigned the name of a compatible subroutine as their value or as the actual
parameter, and can later be called with the same syntax as normal (constant)
subroutines and functions.
</div><div class=page id="Type%20identity">
Node: (cpl)Type identity, Prev: <a href="#Subroutine%20type">Subroutine type</a>, Up: <a href="#Declarations">Declarations</a>
<hr>

<h2>Type identity</h2>

When are two VARIABLEs of the same TYPE? Pascal-like strongly typed languages
only consider variables of the same type when they are declared by the same
typename or they appear in the same compound declaration. In other words,
repeated compound declarations are not considered the same type even when they
are equal, just as are not considered the same type two different typenames
with similar definitions. C, on the other hand, handles typenames as bare
aliases, and compares their definitions directly. None of these languages has
runtime-dimensioned arrays. CPL takes the C approach when possible, and
compares type definitions, but explicitly considers two different typenames
different even when they correspond to the same declaration. Generally, it is
good practice to declare variables that must be of the same type in a single
declaration, or through a single typename, or through <a href="#TYPEOF">TYPEOF</a>. This is
particularly true with runtime-dimensioned arrays (ARRAYs whose bounds are
specified by a VARIABLE and are only known at run time). In fact, since a
VARIABLE may take on different values in different parts of the program,
multiple declarations of this type are necessarily considered different.

In order to test whether a variable is of a given type the <a href="#IS">IS</a>
comparison operator is available.
</div><div class=page id="Statements">
Node: (cpl)Statements, Next: <a href="#Control">Control</a>, Prev: <a href="#Declarations">Declarations</a>, Up: <a href="#Top">Top</a>
<hr>

<h1>Executable statements and expressions</h1>

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#Expressions">Expressions</a>:</td><td>construction and operators</td></tr>
<tr><td><a href="#Assignment">Assignment</a>:</td><td>rules</td></tr>
<tr><td><a href="#Assignment">~:Assignment</a>:</td><td>place-holder for the l.h.s.</td></tr>
<tr><td><a href="#Delayed%20Assignment">Delayed Assignment</a>:</td><td>to be performed where the symbol is used</td></tr>
<tr><td><a href="#Concealed%20Pointer%20Lookup">Implicit type conversion:Concealed Pointer Lookup</a>:</td><td></td></tr>
<tr><td><a href="#WITH">WITH</a>:</td><td>implicit access to structure fields and functions</td></tr>
<tr><td><a href="#NEW">Memory or file allocation:NEW</a>:</td><td>and FREE</td></tr>
<tr><td><a href="#Input/Output">Input/Output</a>:</td><td>formatted and binary</td></tr>
<tr><td><a href="#Control">Control</a>:</td><td>Program flow control statements</td></tr>
</table></nav>
</div><div class=page id="Expressions">
Node: (cpl)Expressions, Next: <a href="#Assignment">Assignment</a>, Prev: <a href="#Statements">Statements</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Expressions</h2>

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#INTEGER%20operator">INTEGER operator</a>:</td><td>+  -  *  DIV  MOD</td></tr>
<tr><td><a href="#REAL%20operator">REAL operator</a>:</td><td>+  -  *  /  ^</td></tr>
<tr><td><a href="#Comparison">Comparison</a>:</td><td>&gt;  &gt;=  &lt;  &lt;=  =  #  IS</td></tr>
<tr><td><a href="#BOOLEAN%20ops">BOOLEAN ops</a>:</td><td>AND  OR  NOT</td></tr>
<tr><td><a href="#Conditional%20expressions">Conditional expressions</a>:</td><td>embedded IF...THEN...ELSE</td></tr>
<tr><td><a href="#Bitwise">Bitwise</a>:</td><td>bitwise boolean operators</td></tr>
<tr><td><a href="#String">String</a>:</td><td>concatenation and conversion</td></tr>
<tr><td><a href="#Looping%20operator">Looping operator</a>:</td><td>SUM  PRODUCT  MIN  MAX</td></tr>
<tr><td><a href="#Builtin">Builtin</a>:</td><td>built-in functions</td></tr>
<tr><td><a href="#subarray">subarray</a>:</td><td>subarray selection</td></tr>
<tr><td><a href="#compound%20index">compound index</a>:</td><td>sequential access to a multidimensional array</td></tr>
<tr><td><a href="#ARRAY%20operations">ARRAY operations</a>:</td><td>linear space</td></tr>
<tr><td><a href="#Einstein%20convention">Einstein convention</a>:</td><td>implicit index iteration</td></tr>
</table></nav>
</div><div class=page id="INTEGER%20operator">
Node: (cpl)INTEGER operator, Next: <a href="#REAL%20operator">REAL operator</a>, Prev: <a href="#Expressions">Expressions</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>INTEGER operators:        +  -  *  DIV  MOD</h3>

DIV is the INTEGER division operator, and produces a truncated INTEGER
quotient. "/" is reserved for REALs, and produces a REAL result even when the
operands are INTEGERs.

MOD is the "modulo" infix operator. If a and b are INTEGERs,

        a MOD b

represents the remainder of the integer division of a by b.
</div><div class=page id="REAL%20operator">
Node: (cpl)REAL operator, Next: <a href="#Comparison">Comparison</a>, Prev: <a href="#INTEGER%20operator">INTEGER operator</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>REAL operators:                +  -  *  /  ^ (or **)</h3>

An infix ^ (or **) is the exponentiation operator. <a href="#Postfix">Postfix</a> ^ is the
pointer dereferencing operator. Also <a href="#Concealed%20Pointer%20Lookup">prefix ^:Concealed Pointer Lookup</a>.
</div><div class=page id="Comparison">
Node: (cpl)Comparison, Next: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>, Prev: <a href="#REAL%20operator">REAL operator</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Comparison:                &gt;  &gt;=  &lt;  &lt;=  =  #  IS</h3>

The equality and inequality operators apply to any type, including pointers.
Since pointers are implicitly dereferenced (<a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>),
an ambiguity may arise as to whether the values or addresses of the two sides
must be compared. The comparison generally takes place at the lowest
dereferencing level at which types match, but the comparison of two constant
addresses is not allowed (so that A = B, where A and B are two simple
variables, denotes the comparison of the values of A and B rather than their
addresses). Explicit type cast or pointer dereferencing may at times be
necessary, and is always advised, where ambiguities exist.

The type-testing operator IS is described in <a href="#DYNAMIC">Object-oriented features:
DYNAMIC</a>.
</div><div class=page id="BOOLEAN%20ops">
Node: (cpl)BOOLEAN ops, Next: <a href="#Conditional%20expressions">Conditional expressions</a>, Prev: <a href="#Comparison">Comparison</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>BOOLEAN operators</h3>

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#AND">AND</a>:</td><td>boolean AND operator</td></tr>
<tr><td><a href="#OR">OR</a>:</td><td>boolean OR operator</td></tr>
<tr><td><a href="#NOT">NOT</a>:</td><td>boolean NOT operator</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
BOOLEAN results are produced by <a href="#Comparison">Comparison</a> and <a href="#Builtin">BOOLEAN:Builtin</a>.
</div><div class=page id="AND">
Node: (cpl)AND,  Next: <a href="#OR">OR</a>,  Prev: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>,  Up: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>
<hr>

AND:                boolean AND operator

Takes precedence over OR but not NOT.

AND may also appear in a FOR clause (<a href="#FOR%20AND">FOR AND</a>) and in <a href="#READ">READ</a>.
</div><div class=page id="OR">
Node: (cpl)OR,  Next: <a href="#NOT">NOT</a>,  Prev: <a href="#AND">AND</a>,  Up: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>
<hr>

OR:                boolean OR operator

Has lower precedence than either AND or NOT.

OR may also appear in a <a href="#READ">READ</a> statement.
</div><div class=page id="NOT">
Node: (cpl)NOT,  Prev: <a href="#OR">OR</a>,  Up: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>
<hr>

NOT:                boolean NOT operator

Has higher precedence than either AND or OR.
</div><div class=page id="Conditional%20expressions">
Node: (cpl)Conditional expressions, Next: <a href="#Bitwise">Bitwise</a>, Prev: <a href="#BOOLEAN%20ops">BOOLEAN ops</a>,  Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Conditional expressions</h3>

        IF &lt;BOOLEAN&gt; THEN &lt;expr1&gt; ELSE &lt;expr2&gt;

is an expression that takes the value of &lt;expr1&gt; if &lt;BOOLEAN&gt; is true and
&lt;expr2&gt; if false. &lt;expr1&gt; and &lt;expr2&gt; must evaluate to values of the same type
(or implicitly convertible to the same type) and this is the type of the
result, which can be embedded in a larger expression like any other operator.
Notice that the ELSE part is mandatory, as otherwise the value would be
undefined.

See also the <a href="#IF">IF</a> statement.
</div><div class=page id="Bitwise">
Node: (cpl)Bitwise, Next: <a href="#String">String</a>, Prev: <a href="#Conditional%20expressions">Conditional expressions</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Bitwise boolean operations: BITAND BITOR BITXOR BITNOT RSHIFTED LSHIFTED</h3>

The C-like notation &amp; | &gt;&gt; &lt;&lt; is also available for BITAND BITOR RSHIFTED
LSHIFTED.
^ and ~ are reserved as the <a href="#REAL%20operator">exponentiation:REAL operator</a>. and the <a href="#Assignment">
placeholder:Assignment</a>.
</div><div class=page id="String">
Node: (cpl)String, Next: <a href="#Looping%20operator">Looping operator</a>, Prev: <a href="#Bitwise">Bitwise</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>String concatenation</h3>

STRINGs written one after the other with no intervening operator (whitespace is
allowed, but newlines must be escaped), either in literal (quoted) form or
through their names, are concatenated into a single <a href="#STRING">STRING</a>. If all of
the STRINGs are literals (i.e., known at compile time), the result will also be
a literal, otherwise it will be a dynamically allocated ARRAY(*) OF CHAR which
is transparently freed at the end of the enclosing code block.

<h3>String conversion</h3>

In addition to STRINGs, values of different type may also appear in a
concatenation, provided the first item is an actual STRING (possibly ""); they
are then implicitly converted to strings just as if they appeared in a <a href="#WRITE">
WRITE</a> statement. Conversion of a string into a numeric value must be handled
explicitly through <a href="/usr/share/info/libc.html#%20String%20and%20Array%20Utilities">(/usr/share/info/libc) String and Array Utilities</a>.

When a string literal is defined in &lt;&lt; DELIMITER notation (<a href="#STRING">STRING</a>), a
variable included as DELIMITER &lt;variable&gt; DELIMITER is concatenated within
the string being defined just as above (whereas DELIMITER &lt;newline&gt; ends the
definition).

</div><div class=page id="Looping%20operator">
Node: (cpl)Looping operator, Next: <a href="#Builtin">Builtin</a>, Prev: <a href="#String">String</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Looping operators</h3>

The four operators  SUM  PRODUCT  MAX  MIN  embody a loop to denote respectively
the sum, product, maximum and minimum of an expression over a running index.
They are constructed as

        SUM &lt;expression&gt; FOR &lt;for clause&gt;
        
and return a value of the same TYPE as &lt;expression&gt;. &lt;for clause&gt; can be of any
form that is allowed in a <a href="#FOR">FOR</a> loop.

For example:

        WRITE (MAX SIN(x) FOR x=0 TO 2 BY 0.5)+(PRODUCT arr(n) FOR ALL n)

See also <a href="#MAX">MAX</a>, <a href="#MIN">MIN</a>.
</div><div class=page id="Builtin">
Node: (cpl)Builtin, Next: <a href="#subarray">subarray</a>, Prev: <a href="#Looping%20operator">Looping operator</a>, Up: <a href="#Expressions">Expressions</a>
<hr>
<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
<h3>Builtin INTEGER functions</h3>

<nav><table>
<tr><td><a href="#ABS">ABS</a>:</td><td>absolute value</td></tr>
<tr><td><a href="#CEILING">CEILING</a>:</td><td>larger or equal integer</td></tr>
<tr><td><a href="#FLOOR">FLOOR</a>:</td><td>lesser or equal integer</td></tr>
<tr><td><a href="#MAX">MAX</a>:</td><td>maximum</td></tr>
<tr><td><a href="#MIN">MIN</a>:</td><td>minimum</td></tr>
<tr><td><a href="#ROUND">ROUND</a>:</td><td>nearest integer</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
<h3>Builtin REAL functions</h3>

<nav><table>
<tr><td><a href="#ABS">ABS</a>:</td><td>absolute value</td></tr>
</table></nav>
  ATAN:                        arctangent
  COS:                        cosine
  EXP:                        exponential
<nav><table>
<tr><td><a href="#GAUSS">GAUSS</a>:</td><td>gaussian distributed random REAL number with variance 1</td></tr>
</table></nav>
  LOG:                        logarithm
<nav><table>
<tr><td><a href="#MAX">MAX</a>:</td><td>maximum</td></tr>
<tr><td><a href="#MAXABS">MAXABS</a>:</td><td>maximum absolute value</td></tr>
<tr><td><a href="#MIN">MIN</a>:</td><td>minimum</td></tr>
<tr><td><a href="#MOD">MOD</a>:</td><td>modulus or absolute value of an ARRAY</td></tr>
<tr><td><a href="#NORM">NORM</a>:</td><td>squared absolute value</td></tr>
<tr><td><a href="#RAND">RAND</a>:</td><td>uniformly distributed in [0,1] random number</td></tr>
</table></nav>
  SIN:                        sine
  TAN:                        tangent

<h3>Builtin BOOLEAN functions</h3>

  EOF:                        end of file
<nav><table>
<tr><td><a href="#INPUTREADY">INPUTREADY</a>:</td><td>test for input ready on a file descriptor or stdin</td></tr>
</table></nav>
  ODD:                        INTEGER argument is odd
<nav><table>
<tr><td><a href="#READ">BOOLEAN:READ</a>:</td><td>read and report success or failure</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
<h3>Builtin type conversion functions</h3>

  CHAR:                        INTEGER to CHAR
  INTEGER:                BOOLEAN to INTEGER (1 for YES, 0 for NO)
  INTEGER:                REAL to INTEGER (same as <a href="#FLOOR">FLOOR</a>)
  REAL:                        INTEGER to REAL (may be omitted)
  SINGLE:                REAL to SINGLE

<h3>Builtin STRING functions</h3>

<nav><table>
<tr><td><a href="#COMMANDLINE">COMMANDLINE</a>:</td><td>command line parameter access</td></tr>
<tr><td><a href="#TRAP">ERRORMESSAGE:TRAP</a>:</td><td>error message string</td></tr>
<tr><td><a href="#String">String</a>:</td><td>Concatenation and conversion.</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
In addition, nearly all C library mathematical and other functions are
transparently available with their original names. See <a href="#C%20interface">C interface</a>.
</div><div class=page id="ABS">
Node: (cpl)ABS,  Next: <a href="#CEILING">CEILING</a>,  Prev: <a href="#Builtin">Builtin</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

ABS:                absolute value

The function ABS returns the absolute value of an INTEGER, REAL or COMPLEX
scalar number. For the modulus of an ARRAY use <a href="#MOD">MOD</a>.
</div><div class=page id="CEILING">
Node: (cpl)CEILING,  Next: <a href="#FLOOR">FLOOR</a>,  Prev: <a href="#ABS">ABS</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

CEILING:        larger or equal integer

The function CEILING returns the larger or equal INTEGER to a given REAL value.
</div><div class=page id="FLOOR">
Node: (cpl)FLOOR,  Next: <a href="#MAX">MAX</a>,  Prev: <a href="#CEILING">CEILING</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

FLOOR:                lesser or equal integer

The function FLOOR returns the lesser or equal INTEGER to a given REAL value.
</div><div class=page id="MAX">
Node: (cpl)MAX,  Next: <a href="#MAXABS">MAXABS</a>,  Prev: <a href="#ABS">ABS</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

MAX:                maximum

The function

        MAX(argument [,argument])

accepts any number of scalar arguments and returns their maximum.

The function

        MAX(array)

returns the maximum of the elements of the array.

MAX without a following bracket is a <a href="#Looping%20operator">Looping operator</a>.
</div><div class=page id="MAXABS">
Node: (cpl)MAXABS,  Next: <a href="#MIN">MIN</a>,  Prev: <a href="#MAX">MAX</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

MAXABS:                maximum absolute value

The function

        MAXABS(array)
        
returns the maximum absolute value of the elements of the array.
</div><div class=page id="MIN">
Node: (cpl)MIN,  Next: <a href="#NORM">NORM</a>,  Prev: <a href="#MAXABS">MAXABS</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

MIN:                minimum

The function

        MIN(argument [,argument])

accepts any number of scalar arguments and returns their minimum.

The function

        MIN(array)

returns the minimum of the elements of the array.

MIN without a following bracket is a <a href="#Looping%20operator">Looping operator</a>.
</div><div class=page id="MOD">
Node: (cpl)MOD,  Next: <a href="#NORM">NORM</a>,  Prev: <a href="#MIN">MIN</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

MOD:                modulus or absolute value of an ARRAY

The function

        MOD(array)

returns the modulus (square root of the <a href="#NORM">NORM</a>) of the array.

MOD is also an <a href="#INTEGER%20operator">INTEGER operator</a>.
</div><div class=page id="NORM">
Node: (cpl)NORM,  Next: <a href="#RAND">RAND</a>,  Prev: <a href="#MOD">MOD</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

NORM:                squared absolute value

The function NORM returns the squared absolute value of either a number or a
whole array.
</div><div class=page id="RAND">
Node: (cpl)RAND,  Next: <a href="#GAUSS">GAUSS</a>,  Prev: <a href="#MIN">MIN</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

RAND:                uniformly distributed in (0,1) random REAL number

The function RAND takes no argument. It is based on the INTEGER C library
function rand, whose seed can be changed with srand (<a href="*manpages*.html#rand">(*manpages*)rand</a>).
</div><div class=page id="GAUSS">
Node: (cpl)GAUSS,  Next: <a href="#ROUND">ROUND</a>,  Prev: <a href="#RAND">RAND</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

GAUSS:                gaussian distributed random REAL number with variance 1

The function GAUSS takes no argument. It is based on <a href="#RAND">RAND</a>, and the
analytic formula (see Knuth, The Art of Computer Programming, chapter on random
numbers):

        GAUSS = SQRT(-2*LOG(RAND())*COS(RAND())
</div><div class=page id="ROUND">
Node: (cpl)ROUND,  Prev: <a href="#GAUSS">GAUSS</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

ROUND:                nearest integer

The function ROUND returns the nearest INTEGER to a given REAL value.
</div><div class=page id="subarray">
Node: (cpl)subarray, Next: <a href="#compound%20index">compound index</a>, Prev: <a href="#Builtin">Builtin</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Subarray selection</h3>

A portion of an array can be selected by specifying new dimensions. For
example, if the declaration is REAL arr(1..10), the notation

        arr(2..5)

denotes an array formed by the elements from 2 to 5 of array arr (which has
larger dimensions). The whole range can also be selected, by the special
dimension *. For instance, if the declaration is REAL arr(1..7,-2..2,3..8),

        arr(2..5,*,6)

denotes a two-dimensional array formed by selecting the range 2..5 of the first
index and the whole range of the second index of array arr, with the third
index set equal to 6.

The most general subarray selection can also specify an offset and one or more
strides. The notation for this is:

        arr(a+b1*(&lt;newdim1&gt;)[+b2*(&lt;newdim2&gt;)...])

where a, b1, b2... are INTEGERs and &lt;newdim&gt; is either a subrange l..h or *.
The meaning of this notation is that the subarray must be formed of those
elements of the original array arr whose index is the specified linear function
of the new index or indices. The latter are either constrained in the
explicitly indicated range l..h or in the maximum admissible range *. In fact,
a general linear expression may be specified, with terms in any order and the
possible occurrence of parentheses.

Another form of subarray selection is index permutation, which in the
particular case of a two-dimensional array becomes matrix transposition.

        arr(*&lt;n&gt;,...)

denotes the array obtained from arr by making the &lt;n&gt;-th index become the first
and shifting forward all the others. Thus the transpose of a matrix A is
A(*2,*), or just A(*2); the alternative notation

        TRANSPOSED(A)

is also provided. &lt;n&gt; is currently limited to 2 or 3.

Finally, a subarray can be extracted from an ARRAY of STRUCTUREs. If the
declaration is, for instance,

        ARRAY(1..10) OF STRUCTURE(INTEGER i; REAL r) arr
        
then by a straightforward notation arr.r is the ARRAY(1..10) OF REAL composed
of all the r fields of each element of arr. Thus, for instance, arr(5).r and
arr.r(5) denote the same REAL field. arr.r is an ARRAY in its own right; it can
be copied, passed as a parameter or subjected to further subarray selections.

It should be noted that all subarray selections are just address manipulations:
no element of the array is ever moved and the selected subarray can appear on
the left as well as on the right side of an assignment and can be passed as a
POINTER TO ARRAY(*) parameter to a function or subroutine. No computational
penalty is incurred because of the sheer size of either the original or the
selected array, but on the other hand any modifications of the subarray also
affect the original.

All subarray selections can also be applied to <a href="#STORED">STORED</a> ARRAYs and <a href="#STRUCTURED">
STRUCTURED</a> ARRAYs.
</div><div class=page id="compound%20index">
Node: (cpl)compound index, Next: <a href="#ARRAY%20operations">ARRAY operations</a>, Prev: <a href="#subarray">subarray</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Compound index</h3>

This CPL address manipulation allows a multidimensional ARRAY to be accessed
sequentially through a single index, for instance in order to apply linear
algebra to it. The syntax for this operation is a sequence of as many * as
indices are to be compounded. For example if V is defined as

        ARRAY(0..4,1..5,-7..7,0..2) OF REAL V

then V(****) is a onedimensional "view" of the same array (as opposed to
V(*,*,*,*) which represents its original arrangement). By the same token
V(*,**,*) is the three-dimensional array obtained by compounding the two
central indices into one. Bounds of a compound index can be retrieved by the
<a href="#LO">:LO</a>. and <a href="#HI">:HI</a>. functions as usual.

Compound indices are restricted to arrays (or portions of them) that are
contiguous in memory. This generally precludes their use after subarray
operations that permute, stride, or restrict the range of indices.
</div><div class=page id="ARRAY%20operations">
Node: (cpl)ARRAY operations, Next: <a href="#Einstein%20convention">Einstein convention</a>, Prev: <a href="#compound%20index">compound index</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Linear-space ARRAY operations</h3>

Linear-space operations are supported on arrays. That is, congruent ARRAYs of
any number of dimensions can be added to or subtracted from each other and
multiplied or divided by a scalar inside an expression, as well as appear on
the left side of an assignment.

The scalar product of two congruent arrays is denoted by the infix operator | .
This is defined as the sum over all dimensions of the products of corresponding
elements. (Except for <a href="#complex">complex</a>)

The constant "0" (but not any other constant) can be assigned as a value to a
whole array.

Some <a href="#builtin">builtin</a> functions operate on whole arrays. A larger set of vector
and matrix algebra operations are supported by the <a href="#(matrix">rbmat:(matrix</a>). and
<a href="#(matrix">cbmat:(matrix</a>). libraries.

Matrix transposition is provided as the <a href="#subarray">TRANSPOSED:subarray</a>. operation.

All ARRAY operations can also be applied to <a href="#STORED">STORED</a> ARRAYs and <a href="#STRUCTURED">
STRUCTURED</a> ARRAYs.
</div><div class=page id="Einstein%20convention">
Node: (cpl)Einstein convention, Next: <a href="#Assignment">Assignment</a>, Prev: <a href="#ARRAY%20operations">ARRAY operations</a>, Up: <a href="#Expressions">Expressions</a>
<hr>

<h3>Implicit looping over array indices</h3>

When indices in an expression are prefixed with $ the Einstein convention is
implied. I.e., in a contraction or a product the Einstein index must appear
exactly twice, and the result will be summed over <a href="#ALL">ALL</a> values of this
index; in a sum and assignment, Einstein indices must appear exactly once in
each and all terms including the l.h.s., and the assignment will be repeated
over <a href="#ALL">ALL</a> values of these indices. For example:

        C($i,$j)=A($i,$j,$m)*B($i,$m,$j)+D($j,$i)

Footnote: the euro symbol would have been appropriate to match the "e" of
Einstein, but is not part of the 7-bit ascii codes so we replaced it by a
currency that is (the $).
</div><div class=page id="Assignment">
Node: (cpl)Assignment, Next: <a href="#Delayed%20assignment">Delayed assignment</a>, Prev: <a href="#Expressions">Expressions</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Assignment</h2>

Assignment is performed by a single "=" sign. The l.h.s. must be a POINTER, and
the r.h.s. is required to be a value of the TYPE pointed to or to be implicitly
convertible to it (<a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>). Compound variables can be
assigned as a whole if types match.

Owing to their omnicomprehensive role, assignment and equality/inequality tests
are the only situations in which pointer dereferencing must be explicit. The
left side of an assignment will never be implicitly dereferenced, and must be
dereferenced by a postfix "^" if assignment of the value pointed to is desired.
For increased clarity, the type of the object to be assigned may also be
specified as in (after the declaration REAL a^,b)

        REAL a=b        equivalent to      a^=b.

On the right-hand side of an assignment the symbol ~ can be used as a
place-holder for the left hand. For example:

        counter = ~ + 2
        listelement = ~.next
        A(i,j,k) = 3 * LOG(~) + gamma(~)                
</div><div class=page id="Delayed%20assignment">
Node: (cpl)Delayed assignment, Next: <a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>, Prev: <a href="#Assignment">Assignment</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Delayed assignment</h2>

When an assignment is performed by a double "==" sign, no statement is
generated in place. The l.h.s. is instead defined to be an alias for the
r.h.s., and the assignment will be performed (and error messages issued, if
any) at the location where this alias is first used.

Delayed assignment permits the appearance on the r.h.s. of yet undefined
variables and functions, provided these will be defined before the l.h.s. is
actually used. It also allows compile-time constants to be given symbolic names
and still be recognized as such.

This construction is further extended in the <a href="symbolic.html#Top">(symbolic)</a> library.
</div><div class=page id="Concealed%20Pointer%20Lookup">
Node: (cpl)Concealed Pointer Lookup, Next: <a href="#WITH">WITH</a>, Prev: <a href="#Delayed%20assignment">Delayed assignment</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Implicit type conversion</h2>

Type consistency in expressions and assignments is enforced. However some types
can be implicitly converted to others. Possible conversions are automatically
checked out in the attempt to build a consistent expression. Only if this turns
out impossible, a compilation error results. The basic rule is that a type can
be implicitly converted to one other type only and that there cannot be closed
type conversion loops. INTEGERs are implicitly converted to REALs. POINTERs are
implicitly converted to the value they point to. Owing to this Concealed
Pointer Lookup, it is hardly ever necessary to explicitly dereference pointers.
When really wanted, the dereferencing operator is a postfix ^ (as in Pascal).
Vice versa, a prefix ^ forces taking the address rather than the value of a
variable; this construction too is rarely needed. Notice however that, in a
the assignment of a previously undeclared CONSTANT,

        c = var

implicitly declares c as a copy of the value of var, whereas

        c=^var
        
declares c as a POINTER to var.
</div><div class=page id="WITH">
Node: (cpl)WITH, Next: <a href="#NEW">NEW</a>, Prev: <a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Implicit access to structure fields and functions</h2>

Like in Pascal or Modula2, a structure may be implicitly selected by the WITH
statement. WITH has both a multi-line form:

        WITH &lt;structure&gt; [,&lt;structure&gt;] [:]
        &lt;block&gt;
        [END WITH]

and a single-line form:

        WITH &lt;structure&gt; [,&lt;structure&gt;] : &lt;single-line-block&gt;

The multi-line form is recognized from the fact that a newline follows the
&lt;structure&gt; or the optional colon; in this case the scope of the statement
extends either to the optional END WITH statement or to the end of the
enclosing block; in the second to the end of line. Within the scope of a WITH
statement the given structure (or structures) is understood wherever a field
name alone appears. For instance, after the declaration

        STRUCTURE(REAL x,y) v1,v2
writing 
        WITH v1: x=v2.y; y=3

becomes equivalent to v1.x=v2.y; v1.y=3, or to x(v1)=y(v2); y(v1)=3.

Given the symmetry of treatment of structure fields and functions by CPL
(<a href="#STRUCTURE">STRUCTURE</a>), a function argument may also be specified in a WITH
clause. Thus, for instance,

        WITH 3: WRITE SIN

is equivalent to WRITE SIN(3). Of course this notation is not very useful for
REAL functions, but becomes handy when functions are defined to access
user-defined compound types as if they were structures.
</div><div class=page id="NEW">
Node: (cpl)NEW,  Next: <a href="#FREE">FREE</a>,  Prev: <a href="#WITH">WITH</a>,  Up: <a href="#Statements">Statements</a>
<hr>

<h2>Memory allocation</h2>

Runtime memory allocation is achieved either through the statement

        NEW &lt;pointer&gt; [,&lt;pointer&gt;]

or the function

        NEW &lt;type&gt;

The NEW statement allocates (through the `malloc' system call) the space
necessary for a variable of the TYPE pointed to by &lt;pointer&gt; and sets &lt;pointer&gt;
to its address. The NEW function returns a <a href="#POINTER">POINTER</a>. to a dynamically
allocated variable of <a href="#TYPE">TYPE</a>. &lt;type&gt;. If applied to a POINTER TO <a href="#STORED">
STORED</a>. or <a href="#FILE">FILE</a>. type, NEW returns a pointer to a temporary file
which will be automatically destroyed when freed or at program termination.

Dynamically allocated space is retained, independently of subroutine scoping,
until it is returned to the system by the <a href="#FREE">FREE</a>. statement.
</div><div class=page id="FREE">
Node: (cpl)FREE,  Next: <a href="#Input/Output">Input/Output</a>,  Prev: <a href="#NEW">NEW</a>,  Up: <a href="#Statements">Statements</a>
<hr>

<h2>Freeing memory or file allocation</h2>

        FREE &lt;pointer&gt; [,&lt;pointer&gt;]

releases the memory space or file pointed to by each &lt;pointer&gt;, which must have
been previously obtained from <a href="#NEW">NEW</a>, <a href="#OPEN">OPEN</a>, or <a href="#CREATE">CREATE</a>.
&lt;pointer&gt; is subsequently zeroed, so that any subsequent dereferencing
generates a visible runtime exception. If &lt;pointer&gt; is a file descriptor,
FREEing it also writes out any previously buffered data.
</div><div class=page id="Input/Output">
Node: (cpl)Input/Output, Next: <a href="#Control">Control</a>, Prev: <a href="#NEW">NEW</a>, Up: <a href="#Statements">Statements</a>
<hr>

<h2>Input/Output</h2>

Text I/O is performed by <a href="#READ">READ</a> and <a href="#WRITE">WRITE</a> instructions on
variables of type <a href="#FILE">FILE</a>, which must be declared like ordinary variables
and associated with a file before being used for I/O. FILE variables can be
implicitly declared if they are <a href="#CONSTANT">CONSTANT</a> and be part of compound types
like all other variables. Association to a file is obtained through <a href="#OPEN">
OPEN</a> and <a href="#CREATE">CREATE</a>. A FILE variable is translated to the C type FILE*,
and can be used in C library I/O functions transparently accessed through the
<a href="#C%20Interface">C Interface</a>.

Sequential binary I/O is performed by adding the <a href="#BINARY">BINARY</a> keyword to the
READ and WRITE instructions. No distinction is made between text and binary
files at the filesystem level.

Random-access binary I/O is where cpl really differs from other languages; see
<a href="#STORED">STORED</a>. A more traditional and lower-level method of random access is
described in <a href="#POSITION">POSITION</a>.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#FILE">FILE</a>:</td><td>buffered file-descriptor type</td></tr>
<tr><td><a href="#WRITE">WRITE</a>:</td><td>output to character files and devices</td></tr>
<tr><td><a href="#READ">READ</a>:</td><td>input from character files and devices</td></tr>
<tr><td><a href="#FROM">FROM</a>:</td><td>input as a function</td></tr>
<tr><td><a href="#PROMPT">PROMPT</a>:</td><td>console prompt</td></tr>
<tr><td><a href="#ASK">ASK</a>:</td><td>console prompting and reading</td></tr>
<tr><td><a href="#BINARY">BINARY</a>:</td><td>binary (unformatted) Input/Output</td></tr>
<tr><td><a href="#STORED">STORED</a>:</td><td>random-access files as disk-resident variables</td></tr>
<tr><td><a href="#OPEN">OPEN</a>:</td><td>open a file and associate a buffered file descriptor</td></tr>
<tr><td><a href="#CREATE">CREATE</a>:</td><td>open a buffered file of zero length</td></tr>
<tr><td><a href="#FREE">FREE</a>:</td><td>close a file and free the associated pointer</td></tr>
<tr><td><a href="#FLUSH">FLUSH</a>:</td><td>flush a file's write buffer</td></tr>
<tr><td><a href="#POSITION">POSITION</a>:</td><td>read or set a file's current position</td></tr>
<tr><td><a href="#INPUTREADY">INPUTREADY</a>:</td><td>test for input ready on a file descriptor or stdin</td></tr>
</table></nav>
</div><div class=page id="FILE">
Node: (cpl)FILE, Next: <a href="#WRITE">WRITE</a>, Prev: <a href="#Input/Output">Input/Output</a>, Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>FILE</h3>

File descriptor type, translated to C type FILE*

The predefined C file descriptors

        stdin, stdout, stderr
        
are also predefined in a CPL program (as are, in fact, most other symbols and
functions in the C stdio library; see <a href="#C%20interface">C interface</a>).

The construction

        FILE OF &lt;type&gt;

is used for random-access files (see <a href="#STORED">STORED</a>).

Type FILE is equivalent to FILE OF CHAR.
</div><div class=page id="WRITE">
Node: (cpl)WRITE,  Next: <a href="#READ">READ</a>,  Prev: <a href="#FILE">FILE</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>WRITE</h3>

The output statement WRITE is used as follows:

        WRITE [TO &lt;file&gt;] [BY NAME] [&lt;outputexpr&gt;] [./.]

&lt;file&gt; can be a file descriptor, of type <a href="#FILE">FILE</a>, such as returned by
<a href="#OPEN">OPEN</a> or <a href="#CREATE">CREATE</a>, or else a string representing a filename. In
the latter case the file is implicitly CREATEd before WRITEing and FREEd
afterwards. If "TO &lt;file&gt;" is omitted, stdout is implied. If &lt;file&gt; is present,
"WRITE TO" may be omitted.

&lt;outputexpr&gt; can be

        &lt;value&gt;[:&lt;format&gt;]

or ",".        &lt;value&gt; can be of any type except POINTER (which if present undergoes
<a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a>). Compound types such as <a href="#ARRAY">ARRAY</a> and
<a href="#STRUCTURE">STRUCTURE</a> are printed in a standard format which is understandable to
<a href="#READ">READ</a>. (If STRUCTURE elements are POINTERs, however, they are printed as
the string "POINTER" and cannot be read back.) If a SUBROUTINE named WRITE is
defined with first argument of type FILE and second argument of a user-defined
TYPE, it is used to print variables of such type. Primitive types are printed
in a default format, unless the numeric part of a C format specifier is
included after a colon.

The default format is initially the C library's default, but may be changed
(down to the end of the enclosing scope) by the declaration DEFAULTFORMAT, e.g.

        DEFAULTFORMAT 1.15

A "," in the sequence of &lt;outputexpr&gt;'s is printed as a tab. &lt;outputexpr&gt;'s may
also be written one after the other without any comma, in  which case they are
just adjoined without any intervening space.

By default WRITE prints a newline at the end of its sequence of &lt;outputexpr&gt;'s.
The optional symbol ./. suppresses this newline and FLUSHes the output instead.

WRITE with no &lt;outputexpr&gt; and no ./. prints just a newline.

If the optional BY NAME qualification is present, WRITE prepends each value
with the expression from which it is produced, in the form name=value. If the
expression is a single identifier, this format can be read back by the
statement READ BY NAME.

WRITE syntax may also be used to convert any expression into a string. See
<a href="#String">String</a>conversion.
</div><div class=page id="READ">
Node: (cpl)READ,  Next: <a href="#FROM">FROM</a>,  Prev: <a href="#WRITE">WRITE</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>READ</h3>

The input statement READ is used as follows:

        READ [BY NAME] [FROM &lt;file&gt;] [&lt;variable&gt; [&lt;conjunction&gt; &lt;variable&gt;]]

&lt;file&gt; can be a file descriptor, of type <a href="#FILE">FILE</a>, such as returned by
<a href="#OPEN">OPEN</a> or <a href="#CREATE">CREATE</a>, or else a string representing a filename. In
the latter case the file is implicitly opened before READ is executed and
closed afterwards. If "FROM &lt;file&gt;" is omitted, stdin is assumed.

&lt;variable&gt; must be a <a href="#VARIABLE">VARIABLE</a> identifier or a <a href="#POINTER">POINTER</a> to a
variable, which can be of any type except POINTER. Compound types such as <a href="#ARRAY">
ARRAY</a> and <a href="#STRUCTURE">STRUCTURE</a> are also accepted; they are expected to appear in
the same format as produced by <a href="#WRITE">WRITE</a>. &lt;variable&gt; can also be a literal
<a href="#STRING">STRING</a>, which is then expected to appear verbatim in the input file. If
&lt;variable&gt; is an ARRAY OF CHAR, characters are read until the array is full or
a newline appears. In all other cases, blanks, tabs and newlines are
automatically skipped. Lines starting with "!" are considered comments and
skipped.

&lt;conjunction&gt; can be "," AND or OR. If "," or AND is used, the joined variables
must both be compulsorily present in the input or an I/O error results. If the
conjunction is OR, only one or the other is expected to be present and the READ
statement succeeds and yields control as soon as one is found.

READ with no variable is also allowed and just blocks until a newline is
received, skipping any other characters that precede it. This statement can be
used to skip lines in a file or to create a pause in execution until a newline
appears in stdin.

READ may also appear as a function in a BOOLEAN expression, and should then be
pronounced as the past participle of the verb "to read". In this form READ is
construed just as above, but returns a BOOLEAN value saying whether reading
was successful or not and never generates an I/O error.

If the optional BY NAME qualifier is present, READ expects to find the value of
each variable preceded by its name in the input file in the form name=value.
</div><div class=page id="FROM">
Node: (cpl)FROM,  Next: <a href="#PROMPT">PROMPT</a>,  Prev: <a href="#READ">READ</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>FROM</h3>

As an auxiliary keyword, FROM is used in <a href="#READ">READ</a>. statements to introduce
the <a href="#FILE">FILE</a> data are read from.

In addition, the construction

        &lt;type declarator&gt; FROM &lt;file&gt;

represents a value of type &lt;type declarator&gt; read from the file descriptor
&lt;file&gt;. This value can directly appear in an expression just as the value of a
function can. As an example,

        WRITE TO stdout 3*(INTEGER FROM stdin)

can replace

        INTEGER temp
        READ FROM stdin temp
        WRITE TO stdout 3*temp
</div><div class=page id="PROMPT">
Node: (cpl)PROMPT,  Next: <a href="#ASK">ASK</a>,  Prev: <a href="#FROM">FROM</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>PROMPT(&lt;string&gt;)</h3>

This is a FILE-valued function that writes &lt;string&gt; to stderr and returns stdin
as its value. This makes a construction such as the following possible:

        REAL x
        READ FROM PROMPT("x?") x

or equivalently

        x=REAL FROM PROMPT("x?")

Both have the same effect as

        REAL x
        WRITE "x?" ./.
        READ x
        
PROMPT will disappear. Use <a href="#ASK">ASK</a> instead.
</div><div class=page id="ASK">
Node: (cpl)ASK,  Next: <a href="#BINARY">BINARY</a>,  Prev: <a href="#PROMPT">PROMPT</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Console prompting and reading</h3>

        ASK [&lt;type&gt;] ["literal":] &lt;variable&gt; [, ["literal":] &lt;variable&gt;]

has the effect that a prompt is automatically written to stderr for each
variable and the value of the variable is subsequently read from stdin. The
prompt is the optional "literal" if present or the name of the variable
followed by a "?" otherwise.

Console prompting can be compounded with CONSTANT declaration. If &lt;type&gt; is
present, each variable is declared as a <a href="#CONSTANT">CONSTANT</a> before being asked.
</div><div class=page id="BINARY">
Node: (cpl)BINARY,  Next: <a href="#STORED">STORED</a>,  Prev: <a href="#ASK">ASK</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Binary (unformatted) Input/Output</h3>

Sequential binary I/O is obtained by appending the word BINARY to either <a href="#READ">
READ</a> or <a href="#WRITE">WRITE</a>, as in

        READ BINARY FROM &lt;file&gt; &lt;variable&gt; [,&lt;variable&gt;]

        WRITE BINARY TO &lt;file&gt; &lt;outputexpr&gt; [,&lt;outputexpr]

In binary I/O no format need, of course, be specified and no newline is
automatically added by WRITE statements.

For random-access binary I/O the statement <a href="#POSITION">POSITION</a> can be used to
get and set the reading and writing position in the file. A more powerful and
frequently preferable mechanism is provided by the <a href="#STORED">STORED</a> declaration.
</div><div class=page id="STORED">
Node: (cpl)STORED,  Next: <a href="#OPEN">OPEN</a>,  Prev: <a href="#BINARY">BINARY</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Random-access files as disk-resident variables</h3>

A random-access binary file typically contains fields and records at fixed
addresses, which can be accessed by POSITIONing the file cursor (<a href="#POSITION">
POSITION</a>) before each READ or WRITE <a href="#BINARY">BINARY</a>. However, this process
requires knowing the address of each field and is quite error-prone.

CPL provides a powerful alternative: a pointer to a compound variable residing
in a disk file. Records and fields are then defined by just declaring a
suitable compound type through the usual <a href="#STRUCTURE">STRUCTURE</a> and <a href="#ARRAY">ARRAY</a>
declarations. For this purpose a type declaration prefixed by the keyword
STORED is used, as in the example:

        POINTER TO STORED ARRAY(1..10) OF STRUCTURE(REAL x,y) v
        
which defines a variable named v as the pointer to a random-access file
containing 10 records composed of two real numbers each. v is in fact an
ordinary file descriptor, which can be obtained from <a href="#OPEN">OPEN</a> or <a href="#CREATE">
CREATE</a>, just like any other file descriptor, or from <a href="#NEW">NEW</a> like any
other POINTER. Once v is assigned a file descriptor, reading and writing to it
is achieved by just accessing v as if it were a memory <a href="#POINTER">POINTER</a>. In the
example, since <a href="#Concealed%20Pointer%20Lookup">Concealed Pointer Lookup</a> is in effect,

        v(4).x = 3.14
and
        WRITE LOG(v(8).y)
        
are valid statements. The rule is simply that anything that could be done if v
had been declared as a normal POINTER is still allowed, but the actual storage
is in a disk file rather than in memory.

Just as for any POINTER, accessing a variable of POINTER TO STORED type without
first assigning a file descriptor to it is an error (caught by <a href="#rtchecks">
rtchecks</a>. if active). On the contrary, the declaration

        STORED ARRAY(1..10) OF STRUCTURE(REAL x,y) v

(using the same example) actually reserves storage for the variable v, just
like the corresponding declaration without the keyword STORED would, by
requesting a temporary file through <a href="#NEW">NEW</a>. This temporary file is
automatically opened and closed as necessary and cannot be explicitly assigned.

When declared with the special dimension *, a STORED ARRAY can contain an
a-priori undetermined number of records (numbered from 0). The shorthand

                        FILE OF &lt;type&gt;
is equivalent to
                        POINTER TO STORED ARRAY(*) OF &lt;type&gt;

The ordinary <a href="#FILE">FILE</a> type declarator is a shorthand for FILE OF CHAR.

STORED ARRAYs and POINTER TO STORED ARRAYs with multiple * dimensions are
allowed as function formal parameters, just like their non-STORED equivalents.
The corresponding actual parameter must be a STORED ARRAY of matching number of
dimensions and type (not just an OPENed file).
</div><div class=page id="OPEN">
Node: (cpl)OPEN,  Next: <a href="#CREATE">CREATE</a>,  Prev: <a href="#STORED">STORED</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Open an existing file and associate a buffered file descriptor with it</h3>

The statement

        OPEN &lt;fd&gt;, &lt;filename&gt;

opens the file descriptor &lt;fd&gt; for the file identified by the string &lt;filename&gt;.
&lt;fd&gt; can be any <a href="#STORED">STORED</a> type.

The function

        OPEN(&lt;filename&gt;)

returns &lt;fd&gt; as its value.

&lt;filename&gt; is opened for both reading and writing, and is created if it does
not exist, but it is never truncated. Therefore, it may be written over but any
data which are not overwritten will remain there. If a possible file of the
same name is to be cleared before writing, <a href="#CREATE">CREATE</a> should be used
instead.

"OPEN" calls the "open" system function with options O_RDWR|O_CREAT. For other
requirements the "fopen" function may be called directly (<a href="#C%20interface">C interface</a>).
</div><div class=page id="CREATE">
Node: (cpl)CREATE,  Next: <a href="#FLUSH">FLUSH</a>,  Prev: <a href="#OPEN">OPEN</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Create a new, empty file</h3>

The statement

        CREATE &lt;fd&gt;, &lt;filename&gt;

opens the file descriptor &lt;fd&gt; for the file identified by the string
&lt;filename&gt;. &lt;fd&gt; can be of <a href="#FILE">FILE</a>, or POINTER TO <a href="#STORED">STORED</a> type.

The function

        CREATE(&lt;filename&gt;)

returns &lt;fd&gt; as its value.

&lt;filename&gt; is opened for both reading and writing, is created if it does not
exist, and is truncated to zero length. Therefore, it may be reread after it
has been written, but any data in a pre-existing file of the same name are
lost. If a possible file of the same name is to be preserved, <a href="#OPEN">OPEN</a>
should be used instead.

"CREATE" calls the "open" system function with options O_RDWR|O_CREAT|O_TRUNC.
For other requirements the "fopen" function may be called directly (<a href="#C%20interface">C
interface</a>).
</div><div class=page id="FLUSH">
Node: (cpl)FLUSH,  Next: <a href="#POSITION">POSITION</a>,  Prev: <a href="#CREATE">CREATE</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Flush a file's write buffer</h3>

The statement

        FLUSH &lt;fd&gt;

writes out any buffered data for the file descriptor &lt;fd&gt;.
</div><div class=page id="POSITION">
Node: (cpl)POSITION, Next: <a href="#INPUTREADY">INPUTREADY</a>, Prev: <a href="#FLUSH">FLUSH</a>, Up: <a href="#Input/Output">Input/Output</a>
<hr>

<h3>Read or set a file's current position</h3>

The statement

        POSITION &lt;fd&gt;, n

sets the current position in file descriptor &lt;fd&gt; so the next READ or WRITE
statement will take effect at byte number n.

The function

        POSITION(&lt;fd&gt;)

returns as an INTEGER the current READ/WRITE position in file descriptor &lt;fd&gt;.
</div><div class=page id="INPUTREADY">
Node: (cpl)INPUTREADY, Next: <a href="#COMMANDLINE">COMMANDLINE</a>, Prev: <a href="#POSITION">POSITION</a>, Up: <a href="#Input/Output">Input/Output</a>
<hr>


<h3>Test for input ready on a file descriptor or stdin</h3>
This function is contained in the inputready library (USE inputready).

The BOOLEAN function

        INPUTREADY(&lt;fd&gt;)

returns YES if there are characters available for input on file descriptor
&lt;fd&gt;. This is mainly of use when &lt;fd&gt; is a terminal, to check that keys have
been pressed before reading. Notice that if the terminal is in line-buffered
mode (as by default Unix terminals are), characters become available only
after a line feed has been entered. Terminal mode may be altered by
<a href="#CHARbyCHAR">CHARbyCHAR</a>.

        INPUTREADY()

is a shorthand for INPUTREADY(stdin).

        INPUTREADY(&lt;fd&gt;,&lt;time&gt;)

waits for input for the given &lt;time&gt; (in seconds, a REAL) before returning NO.

        INPUTREADY(&lt;time&gt;)

is a shorthand for INPUTREADY(stdin,&lt;time&gt;).
</div><div class=page id="COMMANDLINE">
Node: (cpl)COMMANDLINE,  Prev: <a href="#INPUTREADY">INPUTREADY</a>,  Up: <a href="#Builtin">Builtin</a>
<hr>

Command-line parameter access

The command line through which the program was launched is available in the
predefined ARRAY OF STRING

        COMMANDLINE

(the same that is usually named argv in C programs). Therefore the first word
passed after the program name is COMMANDLINE(1), the second is COMMANDLINE(2),
etc. The program name itself is COMMANDLINE(0). The index of the last word
present may be obtained, like for all ARRAYs, as COMMANDLINE.HI
</div><div class=page id="Control">
Node: (cpl)Control,  Next: <a href="#makecpl">makecpl</a>,  Prev: <a href="#Statements">Statements</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Program flow control statements</h1>

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#IF">IF</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#LOOP">LOOP</a>:</td><td>conditional and sequential loops</td></tr>
<tr><td><a href="#DO">DO</a>:</td><td>short form of conditional and sequential loops</td></tr>
<tr><td><a href="#INLINE%20LOOP">INLINE LOOP</a>:</td><td>compile-time loop</td></tr>
<tr><td><a href="#CASE">CASE</a>:</td><td>multiple selection</td></tr>
<tr><td><a href="#CASE%20LOOP">CASE LOOP</a>:</td><td>multiple-choice loop</td></tr>
<tr><td><a href="#EXIT">EXIT</a>:</td><td>exit from loop, module or subroutine</td></tr>
<tr><td><a href="#END">END</a>:</td><td>ends a block</td></tr>
<tr><td><a href="#STOP">STOP</a>:</td><td>stop the program</td></tr>
<tr><td><a href="#ERROR">ERROR</a>:</td><td>signal an error and exit or trigger a TRAP</td></tr>
<tr><td><a href="#TRAP">TRAP</a>:</td><td>error handling</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
</div><div class=page id="IF">
Node: (cpl)IF,  Next: <a href="#LOOP">LOOP</a>,  Prev: <a href="#Control">Control</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Conditional execution</h2>

IF statements have a one-line form and a multi-line form. (For the additional
use of IF inside expressions see <a href="#Conditional%20expressions">Conditional expressions</a>) As in BASIC,
one-line IF statements terminate at the end of a line, whereas multi-line IF
statements are explicitly terminated by END IF. (<a href="#END">END</a>) Multi-line IF
statements have the structure:

        IF &lt;BOOLEAN&gt; THEN
        &lt;block&gt;
        END IF
or
        IF &lt;BOOLEAN&gt; THEN
        &lt;block&gt;
        &lt;else statement&gt;
        
They are recognized by the fact that THEN is the last word on a line.
Single-line IF statements have the structure

        IF &lt;BOOLEAN&gt; THEN &lt;single-line block&gt;
or
        IF &lt;BOOLEAN&gt; THEN &lt;single-line block&gt; END IF
or
        IF &lt;BOOLEAN&gt; THEN &lt;single-line block&gt; &lt;else statement&gt;

&lt;single-line block&gt; may contain multiple statements separated by semicolons but
no newlines. It may, however contain compound statements (such as a LOOP or
another IF statement) that in turn contain newlines in their own body.

The optional &lt;else statement&gt; has the structure

        ELSE
        &lt;block&gt;
        END IF
or
        ELSE &lt;single-line block&gt;
or
        ELSE &lt;single-line block&gt; END IF

Multiple-choice conditionals are simply obtained by nesting another IF in the
&lt;else statement&gt;, e.g.

        IF &lt;BOOLEAN&gt; THEN
        &lt;block&gt;
        ELSE IF &lt;BOOLEAN&gt; THEN
        &lt;block&gt;
        ELSE
        &lt;block&gt;
        END IF
</div><div class=page id="LOOP">
Node: (cpl)LOOP,  Next: <a href="#DO">DO</a>,  Prev: <a href="#IF">IF</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Loops</h2>

Loops tested at their beginning (which are executed zero or more times) are
coded as

        LOOP &lt;test&gt;
        &lt;block&gt;
        REPEAT [LOOP]
or
        LOOP name &lt;test&gt;
        &lt;block&gt;
        REPEAT name

Loops tested at their end (which are always executed one or more times) are
coded as

        LOOP
        &lt;block&gt;
        REPEAT [LOOP] &lt;test&gt;
or
        LOOP name
        &lt;block&gt;
        REPEAT name &lt;test&gt;
        
or else by the <a href="#DO">DO</a> short form.

A named loop can be terminated at any point in its body by the <a href="#EXIT">EXIT</a>
statement. A named loop without &lt;test&gt; is an infinite loop that can only be
terminated by <a href="#EXIT">EXIT</a>.

&lt;test&gt; may be any one of

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#WHILE">WHILE</a>:</td><td>loop continuation condition</td></tr>
<tr><td><a href="#UNTIL">UNTIL</a>:</td><td>loop termination condition</td></tr>
<tr><td><a href="#FOR">FOR</a>:</td><td>indexed loop</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
See also <a href="#INLINE%20LOOP">INLINE LOOP</a>, <a href="#Looping%20operator">Looping operator</a>.
</div><div class=page id="WHILE">
Node: (cpl)WHILE,  Next: <a href="#UNTIL">UNTIL</a>,  Prev: <a href="#LOOP">LOOP</a>,  Up: <a href="#LOOP">LOOP</a>
<hr>

<h3>WHILE loops</h3>

The simplest test that can be used to decide whether to iterate a loop is

        WHILE &lt;BOOLEAN&gt;

For instance,

        DO i=i+1 WHILE i&lt;10
        
will repeat while the boolean condition is true.

WHILE is equivalent to <a href="#UNTIL">UNTIL</a> NOT.
</div><div class=page id="UNTIL">
Node: (cpl)UNTIL,  Next: <a href="#FOR">FOR</a>,  Prev: <a href="#WHILE">WHILE</a>,  Up: <a href="#LOOP">LOOP</a>
<hr>

<h3>UNTIL loops</h3>

The simplest test that can be used to decide whether to terminate a loop is

        UNTIL &lt;BOOLEAN&gt;

For instance,

        DO i=i+1 UNTIL i&gt;10
        
will repeat until the boolean condition becomes true.

UNTIL is equivalent to <a href="#WHILE">WHILE</a> NOT.
See also <a href="#C-style">C-style</a> FOR loops.
</div><div class=page id="FOR">
Node: (cpl)FOR,  Next: <a href="#DO">DO</a>,  Prev: <a href="#UNTIL">UNTIL</a>,  Up: <a href="#LOOP">LOOP</a>
<hr>

<h3>FOR loops</h3>

The &lt;test&gt; for indexed loops is

        FOR &lt;for clause&gt;
        
where the basic &lt;for clause&gt; can be either

        &lt;index&gt; = &lt;lbound&gt; TO &lt;ubound&gt; [BY &lt;step&gt;]
or
        &lt;index&gt; = &lt;ubound&gt; DOWN TO &lt;lbound&gt; [BY &lt;step&gt;]
        
&lt;index&gt; is incremented by &lt;step&gt; in each iteration in the first case and
decremented in the second. The loop terminates when &lt;index&gt; exceeds &lt;ubound&gt; in
the first case or drops below &lt;lbound&gt; in the second. If BY &lt;step&gt; is omitted,
BY 1 is assumed. &lt;lbound&gt;, &lt;ubound&gt; and &lt;step&gt; can all be arbitrary
expressions; notice that a negative &lt;step&gt; in either case generates a
non-terminating loop.

Both INTEGER and REAL types are allowed. &lt;index&gt; may be an already existing
variable or be implicitly declared by the loop itself (<a href="#Declarations">Declarations</a>).
In the latter case it acquires the type of the loop bounds and behaves as a
<a href="#CONSTANT">CONSTANT</a> within the body of the loop. If the index is REAL, BY cannot
be omitted.

FOR clauses can appear in a <a href="#LOOP">LOOP</a>, <a href="#DO">DO</a> and <a href="#Looping%20operator">Looping
operator</a>. In addition to the two basic forms, they can have the following
variants:

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#FOR%20AND">FOR AND</a>:</td><td>multiple loop</td></tr>
<tr><td><a href="#ALL">ALL</a>:</td><td>implicit determination of loop bounds</td></tr>
<tr><td><a href="#TIMES">TIMES</a>:</td><td>repetition by a fixed number of times</td></tr>
<tr><td><a href="#IN">IN</a>:</td><td>run through the elements of an array</td></tr>
<tr><td><a href="#EXCEPT">EXCEPT</a>:</td><td>exclude exceptional values</td></tr>
<tr><td><a href="#C-style">UNTIL:C-style</a>:</td><td>loop with a generic incrementing operator</td></tr>
</table></nav>
</div><div class=page id="FOR%20AND">
Node: (cpl)FOR AND,  Next: <a href="#ALL">ALL</a>,  Prev: <a href="#FOR">FOR</a>,  Up: <a href="#FOR">FOR</a>
<hr>

Two or more FOR loops can be combined in a single &lt;test&gt; through the keyword
AND (not to be confused with the logical <a href="#AND">AND</a> operator), as in the
following example:

        LOOP FOR i1=l1 TO u1 AND i2=l2 TO u2
        &lt;block&gt;
        REPEAT

which is equivalent to

        LOOP FOR i1=l1 TO u1
          LOOP FOR i2=l2 TO u2
          &lt;block&gt;
          REPEAT
        REPEAT
</div><div class=page id="ALL">
Node: (cpl)ALL,  Next: <a href="#TIMES">TIMES</a>,  Prev: <a href="#FOR%20AND">FOR AND</a>,  Up: <a href="#FOR">FOR</a>
<hr>

LOOP FOR ALL &lt;index&gt; [,&lt;index&gt;]

denotes a loop whose bounds are automatically determined as the bounds of the
first ARRAY that &lt;index&gt; appears in. Its use should preferably be limited to
short loops in which only arrays of the same dimensions appear and no index
arithmetics are performed.

ALL can be combined in a multiple loop with AND (<a href="#FOR%20AND">FOR AND</a>), as well as
contain multiple indices separated by a comma. In addition, the lower and upper
bounds of the first array that the index is used in are also available as LO
and HI respectively within the scope of the FOR clause, like in the example:

        DO WRITE A(i,j,k) FOR ALL i,j AND k=LO+2 TO HI-3
</div><div class=page id="TIMES">
Node: (cpl)TIMES,  Next: <a href="#IN">IN</a>,  Prev: <a href="#ALL">ALL</a>,  Up: <a href="#FOR">FOR</a>
<hr>

        LOOP FOR &lt;number&gt; TIMES

does exactly that, when just a counter and no indexing is needed.
</div><div class=page id="IN">
Node: (cpl)IN,  Next: <a href="#EXCEPT">EXCEPT</a>,  Prev: <a href="#TIMES">TIMES</a>,  Up: <a href="#FOR">FOR</a>
<hr>

        LOOP FOR &lt;element&gt; IN &lt;array&gt;

Here &lt;element&gt; is not an INTEGER, but rather a POINTER to elements of the ARRAY
&lt;array&gt;. A LOOP is performed in which &lt;element&gt; runs in succession through all
the elements of the array. As a particular case, a constant array can be
constructed from a set of elements of the same TYPE enclosed in brackets, as in

        LOOP FOR n IN (2,5,11)
</div><div class=page id="EXCEPT">
Node: (cpl)EXCEPT,  Next: <a href="#C-style">C-style</a>,  Prev: <a href="#IN">IN</a>,  Up: <a href="#FOR">FOR</a>
<hr>

LOOP FOR &lt;for clause&gt; EXCEPT &lt;condition&gt; ["," &lt;condition&gt;]

The EXCEPT qualifier added to any of the FOR loop constructions excludes
exceptional values of the index from the iteration. &lt;condition&gt; may be either
an expression of BOOLEAN type, meaning that the loop is skipped when the
&lt;condition&gt; is TRUE, or an expression of the same type as the index, meaning
that the given value is excluded.
</div><div class=page id="C-style">
Node: (cpl)C-style,  Prev: <a href="#EXCEPT">EXCEPT</a>,  Up: <a href="#FOR">FOR</a>
<hr>

LOOP FOR &lt;index&gt; = &lt;start&gt; UNTIL &lt;ending condition&gt; BY &lt;incrementing statement&gt;

is a C-style FOR clause in which the index is not necessarily a number but can
be of any type; for instance, a pointer to a structure.

&lt;index&gt; is implicitly declared, if necessary, to have the same type as &lt;start&gt;
and initialized to this value. &lt;index&gt; is then incremented by executing
&lt;incrementing statement&gt; at the end of each LOOP iteration and treated as a
constant for the scope of the loop. The loop repeats until &lt;ending condition&gt;
(an expression of BOOLEAN type) becomes TRUE.

Either &lt;ending condition&gt; or &lt;incrementing statement&gt; may take an alternative
short form. The short form of &lt;ending condition&gt; is an expression of the same
type as &lt;start&gt;; this is equivalent to the BOOLEAN &lt;index&gt; = &lt;ending
condition&gt;. The short form of &lt;incrementing statement&gt; is a single identifier
denoting a function or structure element. This is a shorthand for &lt;index&gt; =
&lt;incrementing statement&gt;(&lt;index&gt;).
</div><div class=page id="DO">
Node: (cpl)DO,  Next: <a href="#INLINE%20LOOP">INLINE LOOP</a>,  Prev: <a href="#LOOP">LOOP</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Loops (short form)</h2>

A short form for nameless loops tested at the end (which are always executed
one or more times) is

        DO &lt;block&gt; &lt;test&gt;

where &lt;test&gt; may be any one of

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#WHILE">WHILE</a>:</td><td>loop terminating condition</td></tr>
<tr><td><a href="#UNTIL">UNTIL</a>:</td><td>loop terminating condition</td></tr>
<tr><td><a href="#FOR">FOR</a>:</td><td>loop specifier</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
See also <a href="#LOOP">LOOP</a>.
</div><div class=page id="INLINE%20LOOP">
Node: (cpl)INLINE LOOP,  Next: <a href="#CASE">CASE</a>,  Prev: <a href="#DO">DO</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>INLINE LOOP</h2>

The statement

        INLINE LOOP [name] FOR element IN &lt;array&gt;
        &lt;block&gt;
        REPEAT [name]

expands in line by repeating the loop for each element of &lt;array&gt;, whose
dimensions must be known at compile time.
</div><div class=page id="CASE">
Node: (cpl)CASE,  Next: <a href="#CASE%20LOOP">CASE LOOP</a>,  Prev: <a href="#INLINE%20LOOP">INLINE LOOP</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Multiple-choice selection</h2>

A multiple-choice branch is specified as

CASE &lt;INTEGER&gt; OF
tag1: &lt;block&gt;
tag2: &lt;block&gt;
............
tagn: &lt;block&gt;
[ ELSE &lt;block&gt; ]
END CASE

where &lt;INTEGER&gt; is any expression of type INTEGER and tag1, tag2,... tagn are
integer compile-time constants. A list of values separated by commas may also
appear as a tag.
</div><div class=page id="CASE%20LOOP">
Node: (cpl)CASE LOOP,  Next: <a href="#EXIT">EXIT</a>,  Prev: <a href="#CASE">CASE</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Multiple-choice loop</h2>

A multiple-choice loop is specified as

CASE LOOP OF
label1: &lt;block&gt;
        REPEAT &lt;label&gt;
label2: &lt;block&gt;
        REPEAT &lt;label&gt;
..............
labeln: &lt;block&gt;
        REPEAT &lt;label&gt;
END CASE

At the end (or in the interior, possibly inside an inner IF or CASE statement)
of each labelled block, execution may continue at any other label as specified
by the REPEAT statement. If the end of a block is reached without an interven-
ing REPEAT statement, the CASE LOOP ends.

The CASE LOOP construction is functionally equivalent to a CASE in a LOOP, e.g.

ENUM(label1,label2,...labeln,exit) repeat=label1
LOOP WHILE repeat#exit
  next=repeat; repeat=exit
  CASE next OF
  label1: &lt;block&gt;
          repeat=&lt;label&gt;
  label2: &lt;block&gt;
          repeat=&lt;label&gt;
  ..............
  labeln: &lt;block&gt;
          repeat=&lt;label&gt;
  END CASE
REPEAT

CASE LOOP maintains statements in the same order, but is easier to read and is
implemented without auxiliary variables.
</div><div class=page id="EXIT">
Node: (cpl)EXIT,  Next: <a href="#END">END</a>,  Prev: <a href="#CASE">CASE</a>,  Up: <a href="#Control">Control</a>
<hr>

EXIT &lt;name&gt; transfers control past the end of the loop, module, function or
subroutine labelled &lt;name&gt;. EXIT may be nested in an inner scope, such as a
further loop or an IF statement.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#LOOP">LOOP</a>:</td><td>conditional and sequential loops</td></tr>
<tr><td><a href="#MODULE">MODULE</a>:</td><td>separately scoped program block</td></tr>
<tr><td><a href="#FUNCTION">FUNCTION</a>:</td><td>value-returning subroutine</td></tr>
<tr><td><a href="#SUBROUTINE">SUBROUTINE</a>:</td><td>sub-routine</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
</div><div class=page id="END">
Node: (cpl)END,  Next: <a href="#STOP">STOP</a>,  Prev: <a href="#EXIT">EXIT</a>,  Up: <a href="#Control">Control</a>
<hr>

END &lt;name&gt; terminates the body of a module, function or subroutine named
&lt;name&gt;. END IF, END CASE, END WITH, END C SECTION, END FRI SECTION and END TRAP
terminate the corresponding statements.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#MODULE">MODULE</a>:</td><td>separately scoped program block</td></tr>
<tr><td><a href="#FUNCTION">FUNCTION</a>:</td><td>value-returning subroutine</td></tr>
<tr><td><a href="#SUBROUTINE">SUBROUTINE</a>:</td><td>subroutine</td></tr>
<tr><td><a href="#IF">IF</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#CASE">CASE</a>:</td><td>multiple selection</td></tr>
<tr><td><a href="#WITH">WITH</a>:</td><td>implicit access to structure fields and functions</td></tr>
<tr><td><a href="#C%20SECTION">C SECTION</a>:</td><td>transparent C source code inclusion</td></tr>
<tr><td><a href="#FRI%20SECTION">FRI SECTION</a>:</td><td>fri formal-rule code on-the-fly modification</td></tr>
<tr><td><a href="#TRAP">TRAP</a>:</td><td>error handling</td></tr>
</table></nav>
</div><div class=page id="STOP">
Node: (cpl)STOP,  Next: <a href="#ERROR">ERROR</a>,  Prev: <a href="#END">END</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>STOP</h2>

Stop the program and exit (unless intercepted by a <a href="#TRAP">TRAP</a>). Has the same
effect as the SIGINT (^C) signal.
</div><div class=page id="ERROR">
Node: (cpl)ERROR,  Next: <a href="#TRAP">TRAP</a>,  Prev: <a href="#STOP">STOP</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Error signal</h2>

The command

        ERROR &lt;outputexpr&gt;        

writes &lt;outputexpr&gt; to the predefined string variable ERRORMESSAGE and signals
an error. Unless a <a href="#TRAP">TRAP</a> has been set, this causes the program to exit
after writing ERRORMESSAGE to stderr.
</div><div class=page id="TRAP">
Node: (cpl)TRAP,  Prev: <a href="#ERROR">ERROR</a>,  Up: <a href="#Control">Control</a>
<hr>

<h2>Error handling</h2>

An error, either caused by a system signal or by the <a href="#ERROR">ERROR</a> statement,
normally causes the program to terminate after writing a message to stderr. A
trap for errors may be set by the statement

        TRAP
        &lt;block&gt;
        END TRAP
or
        TRAP &lt;literal&gt;
        &lt;block&gt;
        END TRAP

In the first form all errors are trapped; in the second only those whose error
message begins with &lt;literal&gt;. When an error is trapped, &lt;block&gt; gets executed.
The error message that would be printed is available in this block in the
predefined STRING

        ERRORMESSAGE
        
At the END TRAP statement, control is passed to the end of the enclosing block,
where also the scope of the TRAP terminates like that of all other
declarations. Within the body of the TRAP, the exception may be re-raised if 
necessary by the statement

        ERROR ERRORMESSAGE

An exception caused by SIGINT or STOP is accompanied by an empty ERRORMESSAGE.
</div><div class=page id="BY">
Node: (cpl)BY,  Next: <a href="#C%20SECTION">C SECTION</a>,  Prev: <a href="#BOOLEAN">BOOLEAN</a>,  Up: <a href="#Control">Control</a>
<hr>

The auxiliary keyword BY is used in

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#FOR">FOR</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#READ">READ</a>:</td><td>input from character files and devices</td></tr>
<tr><td><a href="#WRITE">WRITE</a>:</td><td>output to character files and devices</td></tr>
</table></nav>
</div><div class=page id="ELSE">
Node: (cpl)ELSE,  Next: <a href="#END">END</a>,  Prev: <a href="#DOWN">DOWN</a>,  Up: <a href="#Control">Control</a>
<hr>

The auxiliary keyword ELSE is used in

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#IF">IF</a>:</td><td>conditionally executed statements</td></tr>
<tr><td><a href="#CASE">CASE</a>:</td><td>multiple-choice selection</td></tr>
</table></nav>
</div><div class=page id="NAME">
Node: (cpl)NAME,  Next: <a href="#NEW">NEW</a>,  Prev: <a href="#MODULE">MODULE</a>,  Up: <a href="#Input/Output">Input/Output</a>
<hr>

The auxiliary keyword NAME is used in

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#READ">READ</a>:</td><td>input from character files and devices</td></tr>
<tr><td><a href="#WRITE">WRITE</a>:</td><td>output to character files and devices</td></tr>
</table></nav>
</div><div class=page id="OF">
Node: (cpl)OF,  Next: <a href="#POINTER">POINTER</a>,  Prev: <a href="#NOT">NOT</a>,  Up: <a href="#Declarations">Declarations</a>
<hr>

The auxiliary keyword OF is used in:

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#ARRAY">ARRAY</a>:</td><td>indexed array type</td></tr>
<tr><td><a href="#CASE">CASE</a>:</td><td>multiple-choice selection</td></tr>
<tr><td><a href="#STORED">FILE:STORED</a>:</td><td>random-access file</td></tr>
</table></nav>
</div><div class=page id="TO">
Node: (cpl)TO,  Next: <a href="#TRAP">TRAP</a>,  Prev: <a href="#TIMES">TIMES</a>,  Up: <a href="#Control">Control</a>
<hr>

The auxiliary keyword TO is used in:

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#FOR">FOR</a>:</td><td>loop specifier</td></tr>
<tr><td><a href="#POINTER">POINTER</a>:</td><td>pointers to memory addresses</td></tr>
<tr><td><a href="#WRITE">WRITE</a>:</td><td>output to character files and devices</td></tr>
</table></nav>
</div><div class=page id="makecpl">
Node: (cpl)makecpl,  Next: <a href="#cpl">cpl</a>,  Prev: <a href="#Control">Control</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Compilation tools and their usage</h1>

The compilation and linking of a cpl <a href="#Source%20file">Source file</a> is managed by a shell
script named makecpl. For most purposes the single command

        makecpl [-a] &lt;programtobecompiled&gt;[.cpl] [local dir] [options]
        
is all that is needed to compile and link the source file
&lt;programtobecompiled&gt;.cpl into the executable file &lt;programtobecompiled&gt;

The task of makecpl is achieved by first running <a href="#cpl">cpl</a>, the CPL-to-C
compiler, which compiles the given source and all other files USEd by it into
corresponding C programs, and simultaneously lists all of the generated files
and any needed pre-existing objects in the makefile &lt;programtobecompiled&gt;.d,
and then running make (<a href="make.html#Top">(make)</a>) on this makefile. Any options possibly
present on the makecpl command line are passed on through make to the system C
compiler and linker, or to the command-line designated compiler.

The default C compiler is make's default; an alternate C compiler can be
specified in the CC environment variable or as CC= on the command line.

The -D and -I options are interpreted by cpl, in addition to being passed to
the C compiler, and provide pre-#defined constants and include directories to
both.

C source and object files are kept in a local subdirectory usually named .cpl
(and therefore hidden from listing under unix convention). An alternate name
can be specified in the environment variable OBJDIR or on the command line.

Only those source files whose corresponding object file does not exist or is
older than the source are actually recompiled. In exceptional cases where a
full re-compilation may be necessary, the command

        makecpl -a &lt;programtobecompiled&gt;
        
achieves this by deleting the object files first.

If your system includes the wget command (on Debian you can install it as "apt
install wget"), makecpl provides the functionality to poll the CPLcode.net
website once a day in the background and inform you when updates become
available. This functionality can be disabled by editing the makecpl script
and turning ENABLE_UPDATES to NO.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#cpl">cpl</a>:</td><td>The CPL-to-C compiler</td></tr>
<tr><td><a href="#fri">fri</a>:</td><td>The Formal Rule Interpreter</td></tr>
<tr><td><a href="#FRI%20SECTION">FRI SECTION</a>:</td><td>Dynamic extension of the CPL language</td></tr>
<tr><td><a href="#infocpl">infocpl</a>:</td><td>info reading script</td></tr>
<tr><td><a href="#icpl">icpl</a>:</td><td>Interactive CPL</td></tr>
</table></nav>
</div><div class=page id="cpl">
Node: (cpl)cpl,  Next: <a href="#fri">fri</a>,  Prev: <a href="#makecpl">makecpl</a>,  Up: <a href="#makecpl">makecpl</a>
<hr>

<h2>The CPL-to-C compiler</h2>

The CPL compiler itself is not an executable file, but rather a formal
description of the language that is interpreted by the Formal Rule Interpreter
<a href="#fri">fri</a>. The cpl file is made executable by the shell convention of having
#!/usr/local/fri/fri as its first line. Where this convention is understood,
the CPL-to-C compilation command is

        cpl &lt;source.cpl&gt;

On systems where the #! convention does not work as expected, this command must
be expanded into

        fri cpl &lt;source.cpl&gt;
</div><div class=page id="fri">
Node: (cpl)fri,  Next: <a href="#FRI%20SECTION">FRI SECTION</a>,  Prev: <a href="#cpl">cpl</a>,  Up: <a href="#makecpl">makecpl</a>
<hr>

<h2>The Formal Rule Interpreter</h2>

The design of most compilers passes through a formal description of the
language that is compiled by a parser generator like yacc into a C program. At
the heart of CPL's extensibility there is a different structure, where a formal
description of the language is never compiled to generate the compiler, but
rather interpreted each time a compilation is run. The engine that does this
is named fri, the Formal Rule Interpreter. If yacc is a compiler-compiler, fri
may be called a compiler-interpreter.

In fact, fri is a quite general pattern-matching engine with its own
meta-language, and only "learns" about CPL when it reads the cpl file every
time the compiler is invoked. Translators for many other languages can in
principle be written in it. The interpreted nature of the CPL compiler, in
addition to having allowed a smooth continued development and fine-tuning over
the years, has the effect that its syntax can be extended on the fly by the
compiled program itself with a few lines of FRI code written in a <a href="#FRI%20SECTION">FRI
SECTION</a>. This possibility is used by <a href="#Library">Library</a> modules in order to
define, for instance, complex-number notation, matrix-algebra operations or
symbolic manipulations.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="fri.html#FRI%20architecture">(fri)FRI architecture</a>:</td><td></td></tr>
<tr><td><a href="fri.html#Opcodes">(fri)Opcodes</a>:</td><td></td></tr>
<tr><td><a href="fri.html#Command%20line">(fri)Command line</a>:</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
For the purpose of compiling a CPL program, fri is usually not invoked directly
but rather through <a href="#makecpl">makecpl</a>.
</div><div class=page id="FRI%20SECTION">
Node: (cpl)FRI SECTION,  Next: <a href="#infocpl">infocpl</a>,  Prev: <a href="#fri">fri</a>,  Up: <a href="#makecpl">makecpl</a>
<hr>

<h3>Dynamic extension of the CPL language</h3>

FRI language excerpts may be inserted at any point of a CPL program block by
the statement

        FRI SECTION
        &lt;FRI code&gt;
        END FRI SECTION
        
This has the effect of dynamically adding new statement constructions and for
all purposes extending the syntax of the language. (See <a href="#fri">fri</a>) Like
everything else in CPL, the new extensions are available from the point where
the FRI SECTION appears through the end of the enclosing block.
</div><div class=page id="infocpl">
Node: (cpl)infocpl,  Next: <a href="#icpl">icpl</a>,  Prev: <a href="#FRI%20SECTION">FRI SECTION</a>,  Up: <a href="#Top">Top</a>
<hr>

<h2>info reading script</h2>

Unless the info file you are reading is registered in the general info tree,
the command for reading it is relatively cumbersome. To encapsulate this
command, the infocpl script exists. Typing just "infocpl" brings you to this
file. Typing "infocpl &lt;keyword&gt;" brings you help about a specific CPL keyword.
</div><div class=page id="icpl">
Node: (cpl)icpl,  Next: <a href="#Library">Library</a>,  Prev: <a href="#infocpl">infocpl</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Interactive CPL</h1>

The interactive CPL interpreter, accepting expressions, statements or commands
at a console prompt, is launched by the command

        icpl

icpl's syntax is totally compatible with CPL's. Any valid CPL statement is
executable at the cpl&gt; prompt. As an extension, when an expression is typed
alone at the cpl&gt; prompt a WRITE statement is implied. "?" brings you to this
Info manual. If you are new to the Info reader, then you can get started by
typing "H" for a list of basic key bindings. Type "q" to quit Info.

<nav><table>
<tr><th>Menu:</th><th></th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="editor.html#Top">readline:(editor)</a>:</td><td>Console input editing keys.</td></tr>
<tr><td><a href="#Syntax">syntax:Syntax</a>:</td><td>CPL language specification.  </td></tr>
<tr><td><a href="#icpl%20commands">icpl commands</a>:</td><td>icpl specific commands.</td></tr>
<tr><td><a href="#icpl%20command%20line">icpl command line</a>:</td><td>parameters.</td></tr>
</table></nav>
</div><div class=page id="icpl%20commands">
Node: (cpl)icpl commands,  Next: <a href="#Library">Library</a>,  Prev: <a href="#icpl">icpl</a>,  Up: <a href="#Top">Top</a>
<hr>

<nav><table>
<tr><th>Menu:</th><th>icpl-specific commands:</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#?">?</a>:</td><td>help</td></tr>
<tr><td><a href="#Top"></a>:</td><td>:                shell commands</td></tr>
<tr><td><a href="#$">$</a>:</td><td>last result</td></tr>
<tr><td><a href="#command%20interpretation">icpl:command interpretation</a>:</td><td>of a run-time generated CPL statement</td></tr>
<tr><td><a href="#clear">clear</a>:</td><td>cancel variable declaration and free its associated storage</td></tr>
<tr><td><a href="editor.html#readline">save:(editor)readline</a>:</td><td>save command history to file</td></tr>
<tr><td><a href="editor.html#readline">load:(editor)readline</a>:</td><td>load and execute command history from file</td></tr>
<tr><td><a href="editor.html#full-screen">edit:(editor)full-screen</a>:</td><td>open file in new full-screen window</td></tr>
<tr><td><a href="editor.html#full-screen">close:(editor)full-screen</a>:</td><td>close present full-screen window</td></tr>
<tr><td><a href="#q">q</a>:</td><td>exit icpl (also :q, useful if q exists as a variable)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
A powerful feature of icpl is its capability to transparently USE (<a href="#USE">USE</a>)
a compiled CPL program or #include (<a href="#C%20interface">C interface</a>) a compiled C program.
All functions and variables in such programs become accessible at the cpl&gt;
prompt as well as at the <a href="#?">?</a> request for info.

For icpl to work, the Formal Rule Interpreter (<a href="#fri">fri</a>) must have been
compiled with readline (<a href="editor.html#Top">(editor)</a>) and dynamic loading
(<a href="*manpages*.html#dlopen">(*manpages*)dlopen</a>) support.

When either an interpreted or a compiled program is running under icpl, <a href="#command%20interpretation">
command interpretation</a> becomes available inside the program, and typing
ctrl-C brings up an <a href="#interactive%20session">interactive session</a> instead of stopping it.

Console input functionality is extended under <a href="#icpl">icpl</a>. An icpl shell is
opened whenever a (compiled or interpreted) program is waiting for input, and
any number of icpl commands can be executed interactively. The first expression
given alone on the command line, which would normally be printed, is instead
returned as input to the waiting program. The simplest way to obtain such
extended capabilities is to run &lt;program&gt; as &lt;icpl program&gt;.
</div><div class=page id="icpl%20command%20line">
Node: (cpl)icpl command line,  Next: <a href="#?">?</a>,  Prev: <a href="#icpl%20commands">icpl commands</a>,  Up: <a href="#icpl">icpl</a>
<hr>

<h2>The icpl command line</h2>

An interactive CPL command can alternately be specified on the
(<a href="#icpl%20command%20line">icpl command line</a>) as in

        icpl &lt;command&gt;

&lt;command&gt; may need to be quoted if it contains characters that are interpreted
by the shell specially. If, either at the console prompt or on the command
line, the name of a CPL file is given as a command without the ".cpl" exten-
sion, this source file is automatically compiled as necessary (if it is more
recent than its executable), and then executed at compiled speed but with
interpreted commands available. If the name of a CPL file is given as a command with the ".cpl" extension included, it is loaded and executed in the inter-
preter as when it appears in an <a href="#INCLUDE">INCLUDE</a> statement. Exploiting the unix
interpreter convention, a CPL source program can be made directly executable
by writing "#!/usr/bin/env icpl" as its first line and turning on the
executable permission flag. (<a href="bash.html#Shell%20Scripts">(bash)Shell Scripts</a>)

The

        icpl
        
command with no arguments launches an interactive icpl session.

icpl followed by a CPL expression (possibly quoted to avoid interpretation by
the shell) calculates and prints that expression.

icpl followed by one or more CPL statements executes those statements and
exits; however if a "-" precedes the list of statements, after the written
statements an interactive session is opened. For instance, a chosen set of
libraries can be loaded by default in an interactive session, if desired, by
defining an alias for "icpl -USE &lt;libraries&gt;". "icpl" with no arguments is
equivalent to "icpl -USE rbmat,cbmat,gnuplot,rtchecks".

Finally, if icpl is executed under a different name (by defining a link to it),
that name is executed as a command after "icpl -". For instance, setup defines
a link to icpl named "edit", which is executed as "icpl - edit". 

When the input of icpl is redirected (or piped) from an alternate source,
commands from that source are interpreted as soon as each line arrives.
</div><div class=page id="?">
Node: (cpl)?,  Next: <a href="#:">:</a>,  Prev: <a href="#icpl%20command%20line">icpl command line</a>,  Up: <a href="#icpl">icpl</a>
<hr>

<h2>The icpl help system</h2>

The ? command given at the cpl&gt; command prompt brings you to the Top of this
info file. ? followed by any user-declared identifier or system-reserved
keyword elicits related help.
</div><div class=page id=":">
Node: (cpl):,  Next: <a href="#$">$</a>,  Prev: <a href="#?">?</a>,  Up: <a href="#icpl">icpl</a>
<hr>

<h2>(icpl) Shell commands</h2>

Any command that is meaningless to icpl, or not the name of a program to be
executed, is passed on to the shell before giving up. Thus most shell commands
can be given directly at the cpl&gt; prompt. In case of ambiguity, passing a
command to the shell can be forced with

        :&lt;shell command&gt;
</div><div class=page id="$">
Node: (cpl)$,  Next: <a href="#command%20interpretation">command interpretation</a>,  Prev: <a href="#:">:</a>,  Up: <a href="#icpl">icpl</a>
<hr>

<h2>(icpl) Last result</h2>

Within an icpl expression, the $ symbol stands for the last result printed out
by a previous command.
</div><div class=page id="command%20interpretation">
Node: (cpl)command interpretation, Next: <a href="#interactive%20session">interactive session</a>, Prev: <a href="#$">$</a>, Up: <a href="#icpl">icpl</a>
<hr>

<h2>(icpl) Command interpretation</h2>

A statement contained in a string &lt;string&gt; can be executed just as it were
typed at the cpl&gt; prompt by the statement

        icpl &lt;string&gt;

The icpl statement is available not only to interpreted but also to compiled
programs, provided the latter are run under icpl, thus enabling the on-the-fly
execution of program-generated statements. All the global variables and
subroutines defined in either the compiled or the interpreted part are
accessible to the run-time generated command.
</div><div class=page id="interactive%20session">
Node: (cpl)interactive session, Prev: <a href="#command%20interpretation">command interpretation</a>, Up: <a href="#icpl">icpl</a>
<hr>

<h2>(icpl) Interactive session</h2>

An interactive icpl session can be started in the middle of a running program
either by the user typing ctrl-C at the controlling terminal (or any other
process giving signal SIGINT), or by the program itself executing the statement

        icpl

The interactive session is available not only to interpreted but also to com-
piled programs, provided the latter are run under icpl to start with. All the
global variables and subroutines defined in either the compiled or the inter-
preted part are accessible to the interactive session. 

The inner session thus opened is signalled by an additional "&gt;" in the command
prompt, and can accept any icpl command. Exiting this inner session with "exit"
or "quit" resumes the suspended program, as also does pressing Enter alone on
an empty line. The new commands

        kill         or         stop
 
kill the interrupted program and return to the session where it was invoked.
</div><div class=page id="Library">
Node: (cpl)Library,  Prev: <a href="#icpl">icpl</a>,  Next: <a href="#rtchecks">rtchecks</a>,  Up: <a href="#Top">Top</a>
<hr>

<h1>Ready to <a href="#USE">USE</a> library of CPL modules</h1>

<nav><table>
<tr><th>Menu:</th><th>The following libraries are included with CPL:</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#rtchecks">rtchecks</a>:</td><td>Run Time bounds Checking and more</td></tr>
<tr><td><a href="complex.html#Top">complex:(complex)</a>:</td><td>Complex numbers</td></tr>
<tr><td><a href="fft.html#Top">fft:(fft)</a>:</td><td>Fast Fourier Transforms</td></tr>
<tr><td><a href="matrix.html#Top">rbmat:(matrix)</a>:</td><td>Real square and Banded Matrix operations</td></tr>
<tr><td><a href="matrix.html#Top">cbmat:(matrix)</a>:</td><td>Complex square and Banded Matrix operations</td></tr>
<tr><td><a href="graphics.html#Top">graphics:(graphics)</a>:</td><td>plotting primitives using GNU plotutils</td></tr>
<tr><td><a href="graphics.html#nographics">nographics:(graphics)nographics</a>:</td><td>fake plotting package (does nothing)</td></tr>
<tr><td><a href="graphics.html#gnuplot">gnuplot:(graphics)gnuplot</a>:</td><td>plotting primitives rendered through gnuplot</td></tr>
<tr><td><a href="graphics.html#strlines">strlines:(graphics)strlines</a>:</td><td>Streamline plotting</td></tr>
<tr><td><a href="parallel.html#Top">parallel:(parallel)</a>:</td><td>Parallel computing</td></tr>
<tr><td><a href="parallel.html#nonparallel">nonparallel:(parallel)nonparallel</a>:</td><td>fake parallel package (does nothing)</td></tr>
<tr><td><a href="symbolic.html#Top">symbolic:(symbolic)</a>:</td><td>Symbolic differentiation</td></tr>
<tr><td><a href="#CHARbyCHAR">CHARbyCHAR</a>:</td><td>live keyboard input</td></tr>
<tr><td><a href="#INPUTREADY">inputready:INPUTREADY</a>:</td><td>test for input ready on a file descriptor or stdin</td></tr>
<tr><td><a href="#lapack-eigv">lapack-eigv</a>:</td><td>interface to LAPACK matrix eigenvalue routines</td></tr>
<tr><td><a href="#matlib">matlib</a>:</td><td>Some basic compact matrix-defining functions</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table></nav>
</div><div class=page id="rtchecks">
Node: (cpl)rtchecks,  Next: <a href="complex.html#Top">(complex)</a>,  Prev: <a href="#Library">Library</a>,  Up: <a href="#Library">Library</a>
<hr>

<h2>Run Time bounds Checking</h2>

The rtchecks.cpl library does not add any new subroutines or instructions, but
modifies already existing ones in such a way as to provide run-time bounds
checking. The impact on performance is considerable; therefore rtchecks should
only (and always) be used during development and later disabled once the
program is deemed to be reliable. In particular:

all array indexing and subarray extraction operations are bounds-checked,
pointers are initialized to NULL and NULL-pointer dereferencing is trapped,
all error messages are modified so as to display the position in the source
code where the error occurred.

<nav><table>
<tr><th>Menu:</th><th>rtchecks specific commands</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#TRACE">TRACE</a>:</td><td>ON                        Turn execution tracing on</td></tr>
<tr><td><a href="#TRACE">TRACE</a>:</td><td>OFF                        Turn execution tracing off</td></tr>
</table></nav>
</div><div class=page id="TRACE">
Node: (cpl)TRACE,  Prev: <a href="#rtchecks">rtchecks</a>,  Up: <a href="#rtchecks">rtchecks</a>
<hr>

<h2>TRACE ON/OFF (also abbreviated TRON/TROFF)</h2>

toggles execution tracing. When tracing is on, instructions from the source
file are displayed in the upper part of the terminal screen while program
output goes to the lower part (unless redirected to a file or to another
terminal). Each block (e.g., subroutine or loop) of execution is displayed on
a new line, thus the last instruction of each block is simultaneously within
sight. Each line is prefixed by its source line number and repetition count.
Immediate keypresses (with no Enter) alter tracing as follows:

P,p: pause. Pause execution, or resume if paused.
Q,q: quit. Interrupt the program and exit (C-c is remapped by icpl, see below)
T,t: TROFF. Turn tracing off and continue running as normal.
C-c,I,i: icpl. Open an icpl (<a href="#icpl">icpl</a>) console inside the paused program,
        wherein global variables can be inspected or changed, and functions
        evaluated. Entering an empty line resumes execution. Only available if
        the program was run from icpl to start with (as in "icpl &lt;program&gt;").
V,v: view. Open a vi window at the present line in the source code, which can
        be explored using all vi commands. Tracing resumes on exit.
        (vi command :q)
&lt;space&gt;,S,s: single step. Advance by a single instruction through the code. 
&lt;tab&gt;,F,f: finish. Finish the current block and resume tracing from the next
        instruction of the enclosing block.
Any other key displays a one-line reminder of the above.
</div><div class=page id="CHARbyCHAR">
Node: (cpl)CHARbyCHAR, Next: <a href="#lapack-eigv">lapack-eigv</a>, Prev: <a href="symbolic.html#Top">(symbolic)</a>, Up: <a href="#Library">Library</a>
<hr>

<h2>Live keyboard input</h2>

The CHARbyCHAR.cpl library contains the system calls (termios) necessary to
activate unbuffered terminal input, so that the input of a single character may
be read immediately (normally input is transferred from the terminal to the
running program one line at a time, i.e. only when a newline is entered).
USEing this library is all that is necessary. Input is then performed as usual.
</div><div class=page id="lapack-eigv">
Node: (cpl)lapack-eigv,  Prev: <a href="#CHARbyCHAR">CHARbyCHAR</a>,  Next: <a href="#matlib">matlib</a>,  Up: <a href="#Library">Library</a>
<hr>

<h2>Interface to LAPACK eigenvalue routines</h2>

The lapack-eigv.cpl library declares the functions

       ARRAY(A.LO..A.HI) OF COMPLEX FUNCTION eigv(REAL A(*,*))

       ARRAY(A.LO..A.HI) OF COMPLEX FUNCTION eigv(COMPLEX A(*,*))

providing the full set of eigenvalues of, respectively, a <a href="#REAL">REAL</a> or a
<a href="#COMPLEX">COMPLEX</a> square matrix.
</div><div class=page id="matlib">
Node: (cpl)matlib,  Prev: <a href="#lapack-eigv">lapack-eigv</a>,  Up: <a href="#Library">Library</a>
<hr>

<h2>Basic matrix-creating functions</h2>

The matlib.cpl library is used by the m2cpl script in order to translate
simple MATLAB programs into their CPL equivalents.

Both matlib and m2cpl are in very preliminary development and only include
the most basic functions.

</div></body></html>
